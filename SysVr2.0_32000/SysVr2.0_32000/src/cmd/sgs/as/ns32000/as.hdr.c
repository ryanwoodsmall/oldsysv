/*
********************************************************************************
*                         Copyright (c) 1985 AT&T                              *
*                           All Rights Reserved                                *
*                                                                              *
*                                                                              *
*          THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T                 *
*        The copyright notice above does not evidence any actual               *
*        or intended publication of such source code.                          *
********************************************************************************
*/
# include <stdio.h>
# include "filehdr.h"
# include "scnhdr.h"
# include "syms.h"
# include "linenum.h"
# include "reloc.h"
# include "as.sym.h"
# include "as.addr.h"
# include "as.cbuf.h"

# define outblock(a,b,c) fwrite((char *)(a),b,1,c)

# define NSECTS 3  /*number of sections generated by assembler */
# define MAGIC NS32WRMAGIC

# define OFFSET FILHSZ+(NSECTS*SCNHSZ)

extern long txtrel, datrel;

extern long txtsize, datsize, bsssize;
extern long nsyms;
extern int rdonly;

long Lnno_cnt = 0, Lnno_base;
long symbase;

FILHDR filhead = {
   MAGIC,      /* magic number */
   NSECTS,     /* number of sections */
   0L,      /* time and date stamp */
   0L,      /* file pointer to symbol table */
   0L,      /* number of symbol table entries */
   0,    /* size of optional header in bytes */
   0 };     /* flags */

static SCNHDR txthead = {
   {
      '.','t','e','x','t','\0','\0','\0'  }
   ,  /* section name */
   0L,               /* physical address */
   0L,               /* virtual address */
   0L,               /* section size */
   0L,              /* file ptr to raw data */
   0L,               /* file ptr to relocation */
   0L,               /* file ptr to line numbers */
   0,             /* number of relocation entries */
   0,             /* number of line number entries */
   0x20L };             /* flags */

static SCNHDR dathead = {
   {
      '.','d','a','t','a','\0','\0','\0'  }
   ,  /* section name */
   0L,               /* physical address */
   0L,               /* virtual address */
   0L,               /* section size */
   0L,               /* file ptr to raw data */
   0L,               /* file ptr to relocation */
   0L,               /* file ptr to line numbers */
   0,             /* number of relocation entries */
   0,             /* number of line number entries */
   0x40L };             /* flags */

static SCNHDR bsshead = {
   {
      '.','b','s','s','\0','\0','\0','\0' }
   ,  /* section name */
   0L,               /* physical address */
   0L,               /* virtual address */
   0L,               /* section size */
   0L,               /* file ptr to raw data */
   0L,               /* file ptr to relocation */
   0L,               /* file ptr to line numbers */
   0,             /* number of relocation entries */
   0,             /* number of line number entries */
   0x80L };             /* flags */

headers(){
   long address, offset, trelsize, drelsize, lnnosize;

   trelsize = (long)txtrel * RELSZ;
   drelsize = (long)datrel * RELSZ;
   lnnosize = Lnno_cnt * LINESZ;
   offset = OFFSET + txtsize + datsize;
   Lnno_base = offset + trelsize + drelsize;
   filhead.f_symptr = symbase = Lnno_base + lnnosize;
   filhead.f_nsyms = nsyms;
   time(&(filhead.f_timdat));
   filhead.f_flags |= (F_LNNO | F_AR32WR);

   txthead.s_size = txtsize;
   if ( txtsize || (rdonly && datsize) )
      txthead.s_scnptr = OFFSET;
   if ( txtrel || (rdonly && datrel) )
      txthead.s_relptr = offset;
   txthead.s_nreloc = txtrel;
   if ( Lnno_cnt )
      txthead.s_lnnoptr = Lnno_base;
   txthead.s_nlnno = Lnno_cnt;

   dathead.s_size = datsize;
   dathead.s_paddr = txtsize;
   dathead.s_vaddr = txtsize;
   if ( datsize )
      dathead.s_scnptr = OFFSET + txtsize;
   if ( datrel )
      dathead.s_relptr = offset + trelsize;
   dathead.s_nreloc = datrel;

   bsshead.s_size = bsssize;
   bsshead.s_paddr = txtsize + datsize;
   bsshead.s_vaddr = txtsize + datsize;

   if ( rdonly ) {
      txthead.s_size += dathead.s_size;
      txthead.s_nreloc += dathead.s_nreloc;
      dathead.s_paddr += datsize;
      dathead.s_vaddr += datsize;
      dathead.s_size = 0;
      dathead.s_scnptr = 0;
      dathead.s_nreloc = 0;
      dathead.s_relptr = 0;
      readonly();
      }

   outblock(&filhead,FILHSZ,stdout);
   outblock(&txthead,SCNHSZ,stdout);
   outblock(&dathead,SCNHSZ,stdout);
   outblock(&bsshead,SCNHSZ,stdout);
}

scn_aux(a,s)
   union auxent *a;
   int s;
{
   SCNHDR *scn;

   strncpy(a,"",18);
   switch ( s ) {
   case 1:
      scn = &txthead; break;
   case 2:
      scn = &dathead; break;
   case 3:
      scn = &bsshead; break;
      }
   a->x_scn.x_scnlen = scn->s_size;
   a->x_scn.x_nreloc = scn->s_nreloc;
   a->x_scn.x_nlinno = scn->s_nlnno;
   a->x_scn.x_linoptr = scn->s_lnnoptr;
}

#	Copyright (c) 1984 AT&T
#	  All Rights Reserved

#	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T
#	The copyright notice above does not evidence any
#	actual or intended publication of such source code.

#ident	"@(#)curses:screen/makefile	1.31.1.7"

#
# cursor package maker
# SYSV makefile for UNIX System V
#
#

# Sources
SLIB=	libcurses.a
MYBIN=	$(ROOT)/usr/bin
USRLIB = $(ROOT)/usr/lib
CTAGS=	ctags
BUILT=	capnames.c term.h keycaps curses.h keyname.c initkeypad.c termcap.c tiget.c 
LINT=	lint
LPASS1=	/usr/lib/lint1
TMP=	$(ROOT)/usr/tmp
DESTDIR = $(ROOT)
AR=	TMPDIR=$(TMP) ar
RM=	rm
LN=	ln
CPPDEFS= -I.
DCPPDEFS= -DDEBUG $(CPPDEFS)
DFLAGS=	-g $(DCPPDEFS)
TFLAGS=	-O $(DCPPDEFS)
CFLAGS=	-O $(CPPDEFS)
SUBOBJS=
LDFLAGS=-n -s
LIBS= 
SHELL=	/bin/sh
.SUFFIXES: .p .d .t

HEADERS=curses.h unctrl.h curses.ext curshdr.h term.h uparm.h

# The following order of .c files was generated by hand, and assumes
# that either setupterm or initscr is called first by the user program.
# It only matters on older SYSV systems (4.0 or earlier) or on the
# PDP-11; since 32 bit 5.0 has a table of contents in the archive.
# This order works on an 11/70 running an early 6.0.
CFILES=	initscr.c newterm.c setterm.c gettmode.c subwin.c newpad.c \
	makenew.c setupterm.c reset_sh.c def_prog.c saveterm.c fixterm.c \
	resetterm.c fixdelay.c baudrate.c halfdelay.c cbreak.c clearok.c \
	crmode.c echo.c erasechar.c has_ic.c has_il.c idlok.c intrflush.c \
	keypad.c killchar.c leaveok.c meta.c nl.c nocbreak.c nocrmode.c \
	nodelay.c noecho.c nonl.c noraw.c notimeout.c raw.c resetty.c \
	savetty.c scrollok.c typeahead.c refresh.c endwin.c ll_refresh.c \
	ll_sub.c ll_scrdown.c trm.c insdelchar.c insdelline.c overwrite.c \
	scanw.c wscanw.c pos.c beep.c ll_trm.c flushinp.c restart.c \
	overlay.c mvprintw.c mvwprintw.c printw.c wprintw.c getstr.c getch.c \
	copywin.c addstr.c addch.c insch.c insertln.c scroll.c \
	m_addstr.c m_addch.c m_clear.c m_erase.c \
	m_initscr.c m_move.c m_newterm.c m_refresh.c \
	wechochar.c pechochar.c ll_echo.c pnoutref.c wnoutref.c doupdate.c \
	mvscanw.c mvwscanw.c delay_out.c ll_newtty.c ll_init.c initkeypad.c \
	putp.c clear.c vidputs.c mvcur.c mvwin.c longname.c box.c \
	termcap.c tgoto.c tparm.c tputs.c tiget.c \
	cio.c capnames.c clrtobot.c clrtoeol.c \
	curses.c delch.c deleteln.c delwin.c erase.c \
	move.c standout.c wattroff.c wattron.c wattrset.c touchwin.c tstp.c \
	unctrl.c vwprintw.c vwscanw.c chkinput.c \
	slk_clear.c slk_init.c slk_label.c slk_nout.c \
	slk_ref.c slk_rest.c slk_set.c slk_touch.c \
	ungetch.c memSset.c curs_set.c delay.c draino.c ec_quit.c flash.c \
	getsyx.c napms.c prefresh.c ripoffline.c set_term.c setsyx.c subpad.c \
	touchline.c trace.c scr_dump.c scr_rest.c scr_init.c garbaged.c \
	keyname.c vsscanf.c V2.makenew.c V2._sprintw.c V2.__sscans.c \
	set_TERM.c del_TERM.c

TICHDRS= compiler.h object.h
TICSRC= tic_main.c tic_hash.c tic_captab.c tic_scan.c tic_error.c \
	tic_parse.c tic_read.c capnames.c

TICOBJS= $(TICSRC:.c=.o)

CHDRS= print.h otermcap.h
BSRC= print.c iexpand.c
BOBJ= print.o iexpand.o
CSRC= captoinfo.c otermcap.c $(BSRC)
COBJ= captoinfo.o otermcap.o $(BOBJ)
ISRC= infocmp.c cexpand.c infotocap.c $(BSRC)
IOBJ= infocmp.o cexpand.o infotocap.o $(BOBJ)

all: $(SLIB) llib-lcurses.ln tools

tools: $(SLIB) tic tput captoinfo infocmp show dumpti

# Regular, optimized objects
OBJS=	$(CFILES:.c=.o)
$(OBJS): ${HEADERS}

# Profiled, optimized objects
POBJS=	$(CFILES:.c=.p)
$(POBJS): ${HEADERS}

# Debugging objects
DOBJS=	$(CFILES:.c=.d)
$(DOBJS): ${HEADERS}

# Tracing objects
# TOBJS=	$(CFILES:.c=.t)
#$(TOBJS): ${HEADERS}

.c.p:
	-mv $*.o $*.O
	${CC} ${CFLAGS} -p -c $*.c
	mv $*.o $*.p
	-mv $*.O $*.o
.c.d:
	-mv $*.o $*.O
	${CC} ${DFLAGS} -c $*.c
	mv $*.o $*.d
	-mv $*.O $*.o
.c.t:
	-mv $*.o $*.O
	${CC} ${TFLAGS} -c $*.c
	mv $*.o $*.t
	-mv $*.O $*.o

dumpti: $(SLIB) setupterm.c
	@echo
	@echo Building dumpti
	@echo
	ln setupterm.c dumpti.c
	$(CC) $(CFLAGS) -DDUMPTI -s dumpti.c $(SLIB) -o dumpti ; rm dumpti.c
	@echo
	@echo dumpti has been built
	@echo

$(SLIB): ${OBJS}
	@echo
	@echo Building libcurses archive
	@echo
	${AR} rv $(SLIB) $?
	@echo
	@echo libcurses has been archived
	@echo

p:	p$(SLIB)
p$(SLIB): ${POBJS}
	rm -f x.c
	${AR} rv p$(SLIB) $?

d:	d$(SLIB)
d$(SLIB): ${HEADERS} ${DOBJS}
	rm -f x.c
	${AR} lrv d$(SLIB) $?

t:	t$(SLIB)
t$(SLIB): ${OBJS}
	rm -f x.c
	${AR} rv t$(SLIB) $?

captoinfo: $(COBJ) $(SLIB)
	$(CC) $(COBJ) $(SLIB) -s -o captoinfo

infocmp: $(IOBJ) $(SLIB)
	$(CC) $(IOBJ) $(SLIB) -s -o infocmp

captoinfo.o:	captoinfo.c curses.h otermcap.h print.h
otermcap.o:	otermcap.c otermcap.h
print.o:	print.c curses.h print.h
iexpand.o:	iexpand.c print.h
cexpand.o:	cexpand.c print.h
infotocap.o:	infotocap.c curses.h
infocmp.o:	infocmp.c curses.h term.h print.h

tic_captab.o:	tic_captab.c compiler.h
tic_error.o:	tic_error.c compiler.h
tic_hash.o:	tic_hash.c compiler.h
tic_main.o:	tic_main.c compiler.h
tic_parse.o:	tic_parse.c compiler.h object.h
tic_read.o:	tic_read.c object.h
tic_scan.o:	tic_scan.c compiler.h

setupterm.o: term.h
term.h capnames.c: caps maketerm.ed
	@echo
	@echo Building term.h
	@echo
	rm -f term.h capnames.c
	ed - < maketerm.ed
	chmod a-w term.h capnames.c
	@echo
	@echo "term.h has been built"
	@echo

keycaps: caps
	@echo
	@echo Building keycaps
	@echo
	grep "KEY_" caps > $(TMP)/keycaps
	if cmp -s $(TMP)/keycaps keycaps;then :;else cp $(TMP)/keycaps keycaps;fi
	rm -f $(TMP)/keycaps
	@echo 
	@echo "keycaps has been built"
	@echo

curses.h: keycaps curses.form curses.ed
	@echo 
	@echo Building ./curses.h
	@echo 
	rm -f curses.h
	ed - < curses.ed
	chmod -w curses.h
	@echo 
	@echo "curses.h has been built"
	@echo 

keyname.c: keycaps keyname.ed
	@echo
	@echo Building keyname.c
	@echo
	rm -f keyname.c
	ed - < keyname.ed
	chmod -w keyname.c
	@echo
	@echo "keyname.c has been built"
	@echo

initkeypad.c: keycaps initkeypad.ed
	@echo
	@echo Building initkeypad.c
	@echo
	rm -f initkeypad.c
	ed - < initkeypad.ed
	chmod -w initkeypad.c
	@echo
	@echo "initkeypad.c has been built"
	@echo

termcap.c:	termcap.form termcap.ed caps
	@echo 
	@echo Building termcap.c
	@echo
	rm -f termcap.c
	ed - < termcap.ed
	rm -f bool num str
	chmod -w termcap.c
	@echo 
	@echo "termcap.c has been built"
	@echo

tiget.c:	tiget.ed caps
	@echo
	@echo Building tiget.c
	@echo
	rm -f tiget.c
	cat /dev/null > tiget.c
	ed - < tiget.ed
	chmod -w tiget.c
	@echo
	@echo "tiget.c has been built"
	@echo

ticclob:
	rm -rf ${TICOBJS} tic

tic: ${TICOBJS}
	@echo
	@echo Building the tic compiler
	@echo
	${CC} -s -o tic ${TICOBJS}
	@echo
	@echo the tic compiler has been built
	@echo

otic: otic.o capnames.o unctrl.o
	${CC} -s -o otic otic.o capnames.o unctrl.o

linttic: ${TICSRC}
	${LINT} ${CPPDEFS} ${TICSRC}

lintinfocmp: ${ISRC}
	${LINT} ${CPPDEFS} ${ISRC}

lintcaptoinfo: ${CSRC}
	${LINT} ${CPPDEFS} ${CSRC}

show:	$(SLIB) show.o
	${CC} ${LDFLAGS} ${CFLAGS} -s -o show show.o $(SLIB)
pshow:	p$(SLIB) show.p
	${CC} ${LDFLAGS} -pg ${CFLAGS} -o pshow show.p p$(SLIB)
dshow:	d$(SLIB) show.d
	${CC} ${LDFLAGS} ${DFLAGS} -o dshow show.d d$(SLIB)
tshow:	t$(SLIB) show.t
	${CC} ${LDFLAGS} ${TFLAGS} -o tshow show.t t$(SLIB)

tput:	$(SLIB) tput.o
	${CC} ${LDFLAGS} ${CFLAGS} -s -o tput tput.o $(SLIB)

testterminfo:	$(SLIB) testterminfo.o
	${CC} ${LDFLAGS} ${CFLAGS} -s -o testterminfo testterminfo.o $(SLIB)

new:	clean tags $(SLIB)

allnew:	clean tags $(SLIB) d$(SLIB) p$(SLIB) t$(SLIB)

allfour: $(SLIB) d$(SLIB) p$(SLIB) t$(SLIB)

clean:
	@echo
	@echo "Removing all .o's"
	@echo
	@rm -f ${OBJS} $(SLIB)
	@echo
	@echo "Removing all .d's"
	@echo
	@rm -f ${DOBJS} d$(SLIB)
	@echo
	@echo "Removing all .p's"
	@echo
	@rm -f ${POBJS} p$(SLIB)
	@echo
	@echo "Removing all .t's"
	@echo
	rm -rf *.o trace a.out
	rm -rf $(BUILT)

clobber: clean
	@rm -rf ${TOBJS} t$(SLIB) $(SLIB) ?$(SLIB)
	rm -rf infocmp show scr page one two cat captoinfo dumpti testterminfo tput tic
	rm -rf llib-lcurses.ln

rmhdrs: 
	@echo
	@echo The build of libcurses generates programs and header files.
	@echo We remove any old versions of these files before we begin.
	@echo
	rm -f $(BUILT)

tags:
	${CTAGS} ${CFILES} $(HEADERS)

lint:
	-ln llib-lcurses llib.c
	@echo ${LINT} ${CPPDEFS} > lint.out
	-${LINT} -hxb ${CPPDEFS} ${CFILES} llib.c >> lint.out
	@echo ${LINT} ${DCPPDEFS} >> lint.out
	-${LINT} -hxb ${DCPPDEFS} ${CFILES} llib.c >> lint.out
	rm -f llib.c

lpr:
	-pr `ls ${HEADERS} | sort` | lpr
	-pr `ls ${CFILES} | sort` | lpr
	-lpq

TPFILES= makefile makefile.bsd makefile.sysv \
	${HEADERS} ${CFILES} \
	${TICHDRS} ${TICSRC} \
	${CHDRS} ${BSRC} ${CSRC} ${ISRC} \
	curses.ed curses.form ns_curses.h \
	termcap.ed termcap.form maketerm.ex tiget.ed \
	tags llib-lcurses TODO caps getopt.c initkeypad.ed \
	keyname.ed otic.c \
	show.c testterminfo.c tput.c

tp:
	tp crm0 `ls ${TPFILES} | uniq`

tar:
	tar crvf curses.tar `ls ${TPFILES} | uniq`

cpio:
	ls ${TPFILES} | uniq | cpio -o > curses.cpio

cpio-c:
	ls ${TPFILES} | uniq | cpio -oc > curses.cpio

cpiotape:
	ls ${TPFILES} | uniq | cpio -oBc > /dev/rmt8

llib-lcurses.ln: llib-lcurses
	$(CC) -E -C -I. -Dlint llib-lcurses | ${LPASS1} -vx -H/usr/tmp/hlint > llib-lcurses.ln
	rm -f /usr/tmp/hlint

install:	all
	cpset $(SLIB) $(USRLIB) 644 bin bin
	cp curses.h term.h unctrl.h $(DESTDIR)/usr/include
	@if [ -d "$(INC)" ] ;\
		then \
			cp curses.h term.h unctrl.h $(INC) ;\
	fi;
	rm -f $(USRLIB)/libtermcap.a
	ln $(USRLIB)/libcurses.a $(USRLIB)/libtermcap.a
	ln $(USRLIB)/libcurses.a $(USRLIB)/libtermlib.a
	cp llib-lcurses llib-lcurses.ln $(USRLIB)
	cpset tic $(MYBIN) 555 bin bin
	cpset captoinfo $(MYBIN) 555 bin bin
	cpset infocmp $(MYBIN) 555 bin bin
	cpset tput $(MYBIN) 555 bin bin
	cpset ../termcap $(ROOT)/etc 555 bin bin

cktmp:
	@echo 
	@echo libcurses.a is built using $(TMP) for work space.
	@echo Verifying the existence of $(TMP).
	@echo
	@if [ -d "$(TMP)" ] ;\
		then \
			echo "\t$(TMP) exists";\
			echo;\
		else  \
			echo "\t$(TMP) not found.";\
			echo "\n\tchange the following line of the makefile and re-run\n\n\t\t\c";\
			grep "TMP=" makefile|grep -v makefile;\
			echo;\
			exit 1;\
	fi;

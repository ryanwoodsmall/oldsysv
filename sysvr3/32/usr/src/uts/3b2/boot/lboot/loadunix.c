/*	Copyright (c) 1984 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)kern-port:boot/lboot/loadunix.c	10.20"

#include <sys/types.h>
#include <a.out.h>
#include <sys/param.h>
#include <sys/dir.h>
#include "lboot.h"
#include <sys/stat.h>
#include <sys/sysmacros.h>
#include <sys/conf.h>
#include <sys/boothdr.h>
#include <sys/extbus.h>
#include "error.h"

#ifdef u3b15
#include <sys/cc.h>
#endif

#ifdef u3b2
#include <sys/sbd.h>

/*
 * Default system devices from VTOC
 */
extern char	*VTOC_devname;		/* driver name associated with boot device */
extern int	VTOC_major;		/* board slot of boot device (major number) */
extern int 	VTOC_minor;		/* device number on controller */
extern int	VTOC_root;		/* partition number */
extern int	VTOC_swap;		/* partition number */
extern int	VTOC_nswap;		/* partition size */
#endif

#define PSYS	0x38000000L		/* System bits of physical address */


/*
 * Driver structure
 *
 * Each driver (or module) existing in /boot is represented by an instance of
 * this structure.  It is built at initialization.  All object files found are
 * referred to as drivers throughout this file -- even though modules (NOTADRV)
 * are sometimes treated specially.
 */

#define	MAXCNTL		56			/* maximum number of controllers allowed per device */

struct	driver
	{
	struct driver  *next;
	char           *name;			/* driver name */
	struct master  *opthdr;			/* optional header from driver object file */
	unsigned char	flag;			/* flags */
	unsigned short	nctl;			/* number of controllers, #C expansion
						 * - actually found in EDT if a real device driver
						 * - number of INCLUDEs if a software driver
						 * - constant 1 if a REQuired driver
						 */
	ushort int_major;			/* The internal major number
						 * generated by self-config
						 */

	/********* end of common elements between struct driver and struct kernel *********/

	unsigned char	ntc_lu;			/* number of logical units across HA,
						 * #S expansion
						 */
	unsigned char	maj[MAXCNTL];		/* board slots (external major number) of each controller
						 *	0000 xxxx - local bus address
						 *	0001 xxxx - ELB address on LBE 14
						 *	0010 xxxx - ELB address on LBE 15
						 */
	unsigned char	sys_bits[MAXCNTL];	/* corresponding ELB sys-bits for devices on LBE */
	long		timestamp;		/* f_timdat from file header */
	long		nsyms;			/* number of symbols from filehdr */
	long		symptr;			/* file pointer to symtab */
	short          *s_index;		/*
						 * Since the .text, .data and .bss sections in a
						 * common object file are not necessarily in the
						 * sequence 1-2-3, this array is used to indirectly
						 * reference the shdr[] array using the original
						 * section number. 
						 *	s_index[.text] == 0
						 *	s_index[.data] == 1
						 *	s_index[.bss] == 2
						 */
	SCNHDR		shdr[3];		/* section headers for .text, .data and .bss */
	};

static struct driver *driver;			/* head of struct driver linked list */

/*
 * Flags
 */
#define	LOAD	0x80		/* load this driver */
#define	INEDT	0x40		/* this driver matched in EDT */
#define ISEBUS	0x20		/* extended bus, set for TC's */
#define	INCLUDE	0x10		/* /etc/system: include this driver */
#define	EXCLUDE	0x08		/* /etc/system: exclude this driver */
#ifdef u3b15
#define	ISLBE	0x04		/* this is the entry for the LBE driver */
#endif
#ifdef u3b2
#define	ISLBE	0x00		/* 3B2 has no such thing as a LBE */
#endif

/*
 * Is this controller on an extended local bus?
 */
#ifdef u3b15
#define	ONLBE(maj)	((maj)&0x30)
#endif
#ifdef u3b2
#define ONLBE(maj)	(FALSE)
#endif

/*
 * Compute external major number for a device on a supported LBE (the LBE must
 * be at local bus address 14 or 15)
 */
#define	LBEMAJ(lba,elb)	((((lba)-13)<<4) | (elb))

/*
 * Given a major number for a device on a LBE, compute the local bus address 
 * (lba) of its LBE and the extended local bus address (elb) of the device
 */
#define	LBELBA(m)	(13+((m)>>4))
#define	LBEELB(m)	((m)&0x0F)

/*
 * Kernel structure
 *
 * The kernel requiring configuration may contain an optional header built by
 * mkboot(1M).  If so, this optional header is saved with this structure.  This
 * structure is linked to the driver linked-list so that all optional headers
 * may be easily accessed.  In some cases, only the driver optional headers are
 * required -- "driver" is the head of this linked-list.  In other cases, all
 * optional headers must be accessed -- "kernel" is the head of this linked-
 * list.
 *
 * This structure must exactly match struct driver up to the point marked
 * in struct driver.  This is done to allow routines such as eval() and
 * initdata() to be passed a "struct kernel" pointer in place of a "struct
 * driver" pointer.
 */
struct	kernel
	{
	struct driver  *next;
	char           *name;			/* bootprogram.path */
	struct master  *opthdr;			/* optional header from kernel object file */
	unsigned char	flag;			/* empty flags field */
	unsigned short	nctl;			/* zero */
	ushort		int_major;		/* zero */
	};

static struct kernel *kernel;			/* head of object file linked list */

/*
 * The Kernel and driver linked list is illustrarted below.
 *
 *         kernel                    driver
 *        +-------+                 +-------+
 *        |   X   |                 |   X   |
 *        +-- | --+                 +-- | --+
 *            |                         |
 *            |                         |
 *            V                         V
 *        +-------------+           +-------------+              +-------------+
 *        |struct kernel|           |struct driver|              |struct driver|
 *        |             |           |             |              |             |
 *        |      X----------------> |      X-------------------> |     NULL    |
 *        |             |           |             |              |             |
 *    +----------X      |       +----------X      |          +----------X      |
 *    |   +-------------+       |   |             |          |   |             |
 *    +-> |struct master|       |   |             |          |   |             |
 *        |             |       |   |             |          |   |             |
 *        |             |       |   |             |          |   |             |
 *        +-------------+       |   |             |          |   |             |
 *                              |   +-------------+          |   +-------------+
 *                              +-> |struct master|          +-> |struct master|
 *                                  |             |              |             |
 *                                  |             |              |             |
 *                                  |             |              +-------------+
 *                                  |             |
 *                                  +-------------+
 */


/*
 * Global variables used during the dynamic loading process
 */
extern address   lowater;		/* low water mark in real memory; set by malloc() */
address          hiwater;		/* high water mark in real memory */

address          virtual0 = -1;		/* real address of virtual 0 */


LOCCTR           text_locctr;		/* .text */
LOCCTR           data_locctr;		/* .data */
LOCCTR           bss_locctr;		/* .bss */

int              edt_count;		/* total number of EDT entries */
int              interrupts;		/* number of interrupt routines required */
int              driver_text;		/* total size of driver text */
int              driver_symbol;		/* maximum number of symbols for any one driver */

struct rtname    rtname[]		/* functions defined in the UNIX kernel */
				={	/*	these must be in one-to-one correspondence with RNULL,RNOSYS,... */
		     /* [RNULL] */	{ "nulldev", NULL },
		     /* [RNOSYS] */	{ "nosys", NULL },
		     /* [RNODEV] */	{ "nodev", NULL },
		     /* [RTRUE] */	{ "rtrue", NULL },
		     /* [RFALSE] */	{ "rfalse", NULL },
		     /* [RFSNULL]*/	{ "fsnull",NULL},
		     /* [RFSTRAY]*/	{ "fsstray",NULL},
		     /* [NOPKG]*/	{ "nopkg",NULL},
		     /* [NOREACH]*/	{ "noreach",NULL},
					0
				 };

static boolean  auto_config;		/* TRUE if an auto-config boot was done */

extern int      Xsym_count;		/* total symbols in Xsymtab */
extern int      Xsym_size;		/* total size of symbol names in Xsymtab */

/*
 * private copies of variables that will be generated for UNIX
 */
int 		fstypcnt;
int             cdevcnt;
int             bdevcnt;
int		fmodcnt;
int 		fsincnt;
short		nfstyp;
struct fstypsw	*fstypswp;
struct fsinfo   *fsinfop;
struct cdevsw   *cdevswp;		/* real address */
struct bdevsw   *bdevswp;		/* real address */
struct fmodsw	*fmodswp;		/* real address */
char            *MAJOR;			/* real address */
char            *MINOR;			/* real address */

int           (**io_init)();		/* ==> malloc()'ed copy */
int           (**next_init)();		/* ==> next entry in *io_init[] */

int           (**io_start)();		/* ==> malloc()'ed copy */
int           (**next_start)();		/* ==> next entry in *io_start[] */

int           (**pwr_clr)();		/* ==> malloc()'ed copy */
int           (**next_pwrclr)();	/* ==> next entry in *pwr_clr[] */

struct s3bconf  *sys3bconfig;		/* ==> malloc()'ed copy */

char             slash_boot[100]	/* /boot directory name */
				={ "/boot" };
char             etcsystem[100];	/* /etc/system path name */
struct s3bboot   bootprogram;		/* /unix path name */

dev_t		 mirrordev[2] = { NODEV, NODEV };
dev_t            rootdev = NODEV;
dev_t            pipedev = NODEV;
dev_t            dumpdev = NODEV;
dev_t            swapdev = NODEV;
daddr_t          swplo = -1;
int              nswap = -1;


/*
 * N_index[i] ==> SYMBOL[i] from a driver object file.  This array is allocated
 *                with sufficient size for the maximum number of symbols from
 *                any one driver.
 *
 * N_value[i] ==  original value of SYMBOL[i] from a driver object file.  This
 *                array is allocated in conjunction with N_index.
 */
static SYMBOL  **N_index;
static address  *N_value;


/*
 * Static function declarations for this file
 */
static int            (*absolute())();
static void             alloc_variables();
static void             build_io_subsys();
static void             catch();
static void             check_param();
static boolean          checkcmp();
static void             config();
static void             xconfig();
static void             confirm();
static void             xconfirm();
static void             dependency();
static void             fake_sect();
static void             findrivers();
static void		fndxbus();
static boolean          function();
static boolean          ignoredt();
static void             initdata();
static void		ldebusgen();
static void             loadriver();
static void             mark();
static void		marktc();
static void             print_configuration();
static int            (*relocatable())();
static struct driver   *searchdriver();
static struct param    *searchparam();
static void		xalloc_s3bconf();
static void		xunalloc_s3bconf();


int XMAJNUM = HTCMAJ;				/* First HA major number */
#define CHKMAJ(x,y) (((x-y) >= LTCMAJ) ? 1:0)	/* x is starting major number,
						 * y is number of majors to
						 * be allocated. 
						 */

/* maintain an extended configuration table for TC's.
 * This is necessary since only one extended HA edt is kept
 * in memory at a time. The extended configuration table is
 * copy to the system configuration table; this table is available
 * to users via sys3b().
 */

int xs3bconfcount = 0;			/* total number of TC's system wide */
struct xs3bconf *XS3BCONFSTART = NULL;	/* pointer to extended configuration
					 * table.
					 */

/* adjxmaj() allocates major numbers for  host adaptor */

boolean
adjxmaj(cnt)
register int cnt;			/* number of major's needed */
{PROGRAM(adjxmaj)
	if(CHKMAJ(XMAJNUM, cnt))

		/* major numbers allocated are within range */

		XMAJNUM -= cnt;
	else
		return(FALSE);

	return(TRUE);
}


/*
 * findrivers()
 *
 * Search the /boot directory, and the EDT and build the driver linked-list; if
 * the driver linked-list cannot be built, set-up a dummy linked-list with:
 *
 *		driver == &driver
 *
 * which can be tested for by:
 *
 *		driver->next == driver
 */
 static
 void
findrivers()
	{PROGRAM(findrivers)

	register struct direct *d = NULL;
	register count, i;
	struct driver *dp;
	int fd;
	char name[DIRSIZ+1];
	struct stat statbuf;
	FILHDR fhdr;
	SCNHDR shdr;

	char sections;

#define	TFOUND	0x08		/* .text section found */
#define	DFOUND	0x04		/* .data section found */
#define	BFOUND	0x02		/* .bss section found */


	/*
	 * if not first time called, we've already read the /boot directory
	 */
	if (driver)
		return;

#if TEST
	elapsed("Begin search of boot directory");
#endif

	/*
	 * build the driver linked-list and read the optional headers for each driver
	 */

	if (chdir(slash_boot) == -1)
		{
		/* <slash_boot>: perror() message */
		error(ER7, slash_boot);
		goto fail2;
		}

	count = 0;

	d = directory(slash_boot);

	do	{
		register struct master *mp;

		strncat(strcpy(name,""), d->d_name, DIRSIZ);

		if (stat(name,&statbuf) == -1)
			{
			/* <name>: perror() message */
			error(ER7, name);
			continue;
			}

		if (statbuf.st_mode & (S_IFDIR|S_IFCHR|S_IFBLK|S_IFIFO))
			continue;

		if ((fd=open(name)) == -1)
			{
			/* <name>: perror() message */
			error(ER7, name);
			continue;
			}

		dp = NULL;

		ON(IOERROR)
			goto badriver;

		read_and_check(fd, (char*)&fhdr, FILHSZ);

		if (fhdr.f_magic == FBOMAGIC)
			{

			if (fhdr.f_opthdr != 0)
				{
				if ((dp=(struct driver*)malloc(sizeof(struct driver) +
								fhdr.f_opthdr +
								(fhdr.f_nscns+1)*sizeof(short) +
								strlen(name)+1)) == NULL)
					{
					close(fd);
					goto fail1;
					}

				dp->ntc_lu = 0;			/* number of TC logical
								 * units across HA
								 */
				dp->flag = 0;

				if (0 == strcmp("LBE",name))
					dp->flag |= ISLBE;

				dp->nctl = 0;
				dp->maj[0] = 0;
				dp->opthdr = mp = (struct master *) (dp + 1);
				dp->s_index = (short *) ((char*)mp + fhdr.f_opthdr);

				for (i=0; i<=fhdr.f_nscns; ++i)
					dp->s_index[i] = -1;

				strcpy(dp->name = (char*)(dp->s_index+fhdr.f_nscns+1), name);

				read_and_check(fd, (char*)mp, fhdr.f_opthdr);
				}

			if (fhdr.f_opthdr == 0 || mp->magic != MMAGIC)
				{
				/* Driver <name>: not processed by mkboot(1M) */
				error(ER12, name);
				goto badriver;
				}

			if (mp->flag & KERNEL)
				/*
				 * ignore kernel object files stored in /boot
				 */
				goto badriver;

 			/* major numbers 72 thru 127 are reserved
			 * for extended bus devices.
			 */

			if (mp->soft >= LTCMAJ)
				{
 				/* Driver <name>: major number greater than 71 */
				error(ER13, name);
				goto badriver;
				}

			dp->timestamp = fhdr.f_timdat;
			dp->nsyms = fhdr.f_nsyms;
			dp->symptr = fhdr.f_symptr;

			driver_symbol = max((long)driver_symbol, fhdr.f_nsyms);

			sections = 0;

			for (i=1; fhdr.f_nscns-- != 0; ++i)
				{
				read_and_check(fd, (char*)&shdr, SCNHSZ);

				if (0 == strcmp(".text",shdr.s_name))
					{
					sections |= TFOUND;
					dp->shdr[ dp->s_index[i] = 0 ] = shdr;
					}
				if (0 == strcmp(".data",shdr.s_name))
					{
					sections |= DFOUND;
					dp->shdr[ dp->s_index[i] = 1 ] = shdr;
					}
				if (0 == strcmp(".bss",shdr.s_name))
					{
					sections |= BFOUND;
					dp->shdr[ dp->s_index[i] = 2 ] = shdr;
					}
				}

			if (!(sections & TFOUND))
				{
				/* Driver <dp->name>: missing section .text */
				error(ER14, dp->name);
				goto badriver;
				}
			if (!(sections & DFOUND))
				fake_sect(&dp->shdr[1], ".data", STYP_DATA);
			if (!(sections & BFOUND))
				fake_sect(&dp->shdr[2], ".bss", STYP_BSS);


			/*
			 * driver is OK
			 */

			++count;

			dp->next = driver;
			driver = dp;
			}
		else
			{
			/* Driver <name>: not a valid object file */
			error(ER15, name);
		badriver:
			if (dp)
				free((char*)dp);
			}

		close(fd);
		}
		while ((d=directory((char*)NULL)) != NULL);

	if (count <= 0)
		{
		/* <slash_boot>: No drivers */
		error(ER16, slash_boot);
		goto fail2;
		}

	/*
	 * search the EDT and mark those drivers that are matched
	 */
	edtscan(EDT_START, 0, mark);

#if TEST
	elapsed("Driver linked-list built");

#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	(void) chdir("/");

	return;


	/*
	 * Error return; cleanup and set driver linked-list empty
	 */
fail1:
	printf("No memory for driver linked-list\n");

	if (dp = driver)
		while ((driver=dp) != NULL)
			{
			dp = dp->next;

			free((char*)driver);
			}

	while (directory((char*)NULL) != NULL)
		continue;

fail2:
	(void) chdir("/");

	/*
	 * set driver linked-list empty
	 */
	driver = (struct driver *) &driver;
	}
/*
 * fake_sect
 *
 * Driver is missing .data or .bss section header (missing .text is not
 * allowed).  Fake up a header for a zero-length section.
 */

 static
 void
fake_sect(shdr, name, flags)
	register SCNHDR *shdr;
	char *name;
	long flags;
	{PROGRAM(fake_sect)

	static SCNHDR null_shdr = { 0 };

	*shdr = null_shdr;
	strcpy(shdr->s_name, name);
	shdr->s_flags = flags;
	}

/*
 * Mark(edtp, lba, elb)
 *
 * Mark the driver for this edt entry if such a driver exists.  Lba and elb are:
 *
 *				lba	elb
 *				----	----
 *	non-LBE device		   0	3-15
 *	LBE device		3-15	1-15
 */
#ifdef u3b15
 static
 void
mark(edtp, lba, elb)
	register struct edt *edtp;
	int lba, elb;
	{PROGRAM(mark)

	register struct driver *dp;


	/*
	 * ignore IOA controlled devices
	 */
	if (edtp->ioa_edti != 0)
		return;

	/*
	 * count the total number of EDT entries; this will be needed later
	 * when the s3bconf structure is constructed
	 */
	++edt_count;

	if ((dp=searchdriver(edtp->dev_name)) == NULL)
		/*
		 * no driver for this device found; since the /etc/system
		 * file has not yet been processed, it is not known whether
		 * this situation is an error or whether this entry is to
		 * be ignored
		 */
		return;

	/*
	 * make sure LBE's are only found at local bus addresses 14 & 15;
	 * edtscan() insures that LBE's only exist on the local bus
	 */
	if (dp->flag & ISLBE)
		if (elb != 14 && elb != 15)
			{
			/* LBE ignored at board code <elb>; LBE must be at board code 14 or 15 */
			error(ER17, elb);
			return;
			}

	/*
	 * mark this driver
	 */
	dp->flag |= INEDT;

	if (lba == 0)
		dp->maj[dp->nctl] = elb;
	else
		if (lba == 14 || lba == 15)
			/*
			 * device is on a valid LBE
			 */
			{
			dp->maj[dp->nctl] = LBEMAJ(lba,elb);
			dp->sys_bits[dp->nctl] = (edtp->lb_baddr & PSYS) >> 27;
			}

	if (++dp->nctl >= MAXCNTL)
		/* MAXCNTL exceeded */
		error(ER2);
	}
#endif

#ifdef u3b2
 static
 void
mark(edtp, lba, elb)
	register struct edt *edtp;
	int lba, elb;
	{PROGRAM(mark)

	register struct driver *dp;


	/*
	 * count the total number of EDT entries; this will be needed later
	 * when the s3bconf structure is constructed
	 */
	++edt_count;

	if ((dp=searchdriver(edtp->dev_name)) == NULL)
		/*
		 * no driver for this device found; since the /etc/system
		 * file has not yet been processed, it is not known whether
		 * this situation is an error or whether this entry is to
		 * be ignored
		 */
		return;

	/*
	 * mark this driver
	 */
	dp->flag |= INEDT;

	dp->maj[dp->nctl] = elb;

	if (++dp->nctl >= MAXCNTL)
		/* MAXCNTL exceeded */
		error(ER2);

	}
#endif

/* marktc() mark target controller TC entry, assign major
 * number and adjust HA entry for this TC
 */

static 
void
marktc(hadp, tcdp, maj, maxlu, maxnumtc, maxnumlu, haslot)
register struct driver *hadp, *tcdp;		/* ha, tc driver pointers */
register int maj, maxlu;			/* major number, max logical
						 * units per this TC
register int maxnumtc, maxnumlu, haslot;	 * max target controllers per
						 * ha, ha's max logical units
						 * per TC
						 */
{PROGRAM(marktc)
	boolean fail;

	tcdp->flag |= ISEBUS;			/* set extended bus flag */
	tcdp->maj[tcdp->nctl] = maj;		/* external major for this TC */

	if(++tcdp->nctl >= MAXCNTL){
		/* MAXCNTL exceed for this HA */

		fail = error(ER87, haslot);
		if(fail)
			goto fexit;
	}


 	if((hadp->ntc_lu += maxlu) > (hadp->nctl*(maxnumtc - 1)*maxnumlu)){
		/* MAX LU's exceeded for this HA */
		/* maxnumtc's has 1 subtracted because the HA takes up
		   one TC slot so there is really 1 less TC than the number
		   of slots available. */ 

		fail = error(ER88, hadp->name);
		if(fail)
			goto fexit;
	}
	return;
fexit:
	SIGNAL(ABORT);		/* your out */
}

/* fndxbus() checks edt for extended bus type (indir_dev) */

static
void
fndxbus(edtp, lba, elb)
register struct edt *edtp;
int lba, elb;
{PROGRAM(fndxbus)
	struct driver *dp;

	if (edtp->indir_dev)
		/* Found HA two level device */

		if ((dp=searchdriver(edtp->dev_name))!=NULL && !(dp->flag & EXCLUDE))
			/*
			 * Driver exists in /boot and not EXCLUDED,
			 * therefore load and execute bus generator
			 * program for this HA.
			 */

			ldebusgen(dp, elb, edtp->dev_name);	/* load and execute HA gen program */
		else
			if(dp == NULL){
					/* driver missing, check for boot device */
				if(elb == ((P_CMDQ->b_dev>>4) & 0x0f))
					if(error(ER91, edtp->dev_name, elb))
						SIGNAL(ABORT);
			}else
				/* HA has been excluded, check for boot device */

				if(elb == ((P_CMDQ->b_dev>>4) & 0x0f))
					if(error(ER92, dp->name, elb))
						SIGNAL(ABORT);
}
	

/* load HA generator programs to initialize HA edt */
static void
ldebusgen(dp, slot, haname)
register struct driver *dp;
register slot;
register char *haname;
{PROGRAM(ldebusgen)

	register char *p;
	register int fd;
	extern address maxmem;
	static char path[81];
	static char edtname[] = {"/edt/"}, gename[] = {"edtgen"};
	struct stat statbuf;
	FILHDR fhdr;
	int (*edtgen)(), cnt;
	boolean fail;
	extern void xedtscan();
	

	if(maxmem < IMEG+MAINSTORE){
		error(ER79);	/* need a minimum of 1 meg to configure 
				 * HA device, TC under this HA will be
				 * ignored.
				 */
		return;
	}

	p = path;		/* edtgen file */
	strcat(strcat(strcpy(p, edtname), haname), "/");
	strcat(p, gename);

	if(stat(path, &statbuf) == -1 || (fd=open(path)) == -1){
		error(ER80, path);
		return;
	}

	if(!(statbuf.st_mode & (S_IEXEC|S_IEXEC>>3|S_IEXEC>>6)))
		error(ER31, path);

	ON(IOERROR)
		goto exit;

	read_and_check(fd, (char *)&fhdr, FILHSZ);

	if(fhdr.f_magic != FBOMAGIC){
		/* file is not MAC32 */

		error(ER32, path);
		goto exit;
	}

	if(!(fhdr.f_flags & F_EXEC)){
		/* file not 3b2 exec. */

		error(ER81, path);
		goto exit;
	}

	if(fhdr.f_nscns == 0){
		/* no section headers */

		error(ER33, path);
		goto exit;
	}
	close(fd);
	fd = -1;

	ON(ABORT)
		goto exit;

	edtgen = absolute(path);		/* load edtgen */

	if(!((*edtgen)(slot, XMAJNUM, XEDT_START))){
			/* edtgen exec. failed */

		error(ER82, path, slot);
		goto exit;
	}

	/* check to see if major numbers assigned are within range */

	cnt = ((B_EDT *)XEDT_START)->max_tc;	/* number of majors assigned */

	if(cnt < 1 || cnt > 15){
			/* invalid TC count */
		error(ER83, cnt, slot); /* Invalid HA in slot X */
		goto exit;
	}else

		if(!adjxmaj(cnt)){
			/* major numbers are not within range */

			fail = error(ER84, XMAJNUM, XMAJNUM-cnt+1, slot);
			if(fail)
				SIGNAL(ABORT); 		/* no return from here */
		}


	xedtscan(XEDT_START, dp, slot);		/* scan HA edt to configure
						 * target controllers
						 */
exit:
	if(fd != -1)
		close(fd);
}

/* xedtscan scan HA extended edt and initialize 
 * TC driver entry
 */

void
xedtscan(xedt, hadp, haslot)
register B_EDT *xedt;
register struct driver *hadp;
register int haslot;
{PROGRAM(xedtscan)
	register struct driver *tcdp;		/* pointer to TC driver entry */
	register B_TC *xtcp;			/* pointer to TC */
 	int  i, j, maxlu;
	unsigned int maj;			/* maj number of TC */
	boolean fail;
	char *tcname;			/* name of TC */
	int haboot = FALSE;		/* HA boot */
	int tcbootdv;			/* boot TC */

	i = j = 0;			/* loop counters */
	xtcp = xedt->tc;		/* xtcp pointer to TC array */

	/* check for HA boot device */
	
	if(auto_config && (haslot == ((P_CMDQ->b_dev>>4) & 0x0f)) && rootdev == NODEV){
		haboot = TRUE;		/* boot device is under this HA */
		tcbootdv = ((P_CMDQ->b_dev & 0x0f)+1); /* boot TC */
	}

	/* scan HA edt and configure those devices that are equipped,
	 * a check is done to ensure we don't kill ourselves 
	 * by running off the end of the extended edt.
	 */

	while((i<xedt->n_tcs) && (j<xedt->max_tc)){
		++j;		/* allowable number of TC's per HA */

		if(xtcp->equip_stat){
			++i;		/* found equipped TC */
 			maj = xtcp->maj;	/* major number for this TC */
 			maxlu = xtcp->max_lu;	/* max number of lu's for this TC type */
			tcname = (char *)xtcp->name;
			/* allocate extended config table entry 
			 * for TC.
			 */

			xalloc_s3bconf(maj, tcname, haslot);
 			if(!auto_config){
				/* For absolute boot we just
				 * need to build incore extended
				 * configuration table
				 */
				xtcp = (B_TC *)((caddr_t)xtcp + xedt->tc_size);
				continue;
 			}

			if((tcdp=searchdriver(tcname)) == NULL){
				if(haboot && tcbootdv == i){
					/* driver not found for boot TC, fatal error */
					if(error(ER94, tcname, hadp->name, haslot))
						SIGNAL(ABORT);
				}else
					if(!(ignoredt(tcname)))

						error(ER85, tcname, haslot);
			}else
				if(tcdp->flag & EXCLUDE){
					/* TC has been excluded, check
					 * if boot TC
					 */

					if(haboot && tcbootdv==i)
						if(error(ER93, tcname, hadp->name, haslot))
							SIGNAL(ABORT);
				}else{
					/* TC itself has not been
					 * excluded, mark driver entry
					 */

 					marktc(hadp, tcdp, maj, maxlu, xedt->max_tc, xedt->max_lu, haslot);
					if(haboot && tcbootdv == i){
						/* set VTOC to this TC */
						VTOC_major = maj;	/* maj number for TC */
						VTOC_minor = 0;		/* TC boot drive is 0 */
						VTOC_devname = tcname;	/* TC driver name */
					}
				}
					
		}

		xtcp = (B_TC *)((caddr_t)xtcp + xedt->tc_size); /* look at next TC */
	}

	if (i != xedt->n_tcs){
			/* reported equipage value differs
			 * from actual configuration
			 */

		fail = error(ER89, haslot, xedt->n_tcs, i);
		if(fail)
			SIGNAL(ABORT);
	}
}
 

/*
 * Print_configuration()
 *
 * Print the configuration table; this is only done if the auto-boot
 * switch is off and QuietMode is FALSE
 */
 static
 void
print_configuration()
	{PROGRAM(print_configuration)

	register struct driver *dp;
	register struct master *mp;
	register int i;
	register boolean issued;
	char buffer[DIRSIZ+1];
	extern boolean QuietMode;


	if (QuietMode || (QuietMode = break_hit()))
		return;

	printf("\nCONFIGURATION SUMMARY\n=====================\n     ----driver---- #devices major\n");
	/*                                                     \n     DIRSIZ__LENGTH nnnnn   nnnn,nnnn */

	if ((dp = driver) != NULL)
		{
		/*
		 * handle drivers
		 */
		do	{
			if (! (dp->flag & LOAD) ||
			   ((mp=dp->opthdr)->flag & NOTADRV))
				continue;
			if ((mp->flag & (CHAR | BLOCK | FUNMOD | FUNDRV)) == FUNMOD)
				continue;

			if (QuietMode = break_hit())
				{
				printf("\n");
				return;
				}

			strcpy(buffer, dp->name);
			strncat(buffer, "              ", (int)(sizeof(buffer)-1-strlen(buffer)));

			printf("     %s %s   ", buffer, itoa((int)dp->nctl)+10);

			if (! (mp->flag & (BLOCK|CHAR|FUNDRV)))
				printf("\n");
			else
				if (mp->flag & SOFT)
					printf("%s\n", itoa((int)mp->soft)+11);
				else
					{
					for (i=0; i<dp->nctl; ++i)
						printf((i+1==dp->nctl)?"%s\n":"%s,", itoa((int)dp->maj[i])+11);
					}
			}
			while (dp = dp->next);

		/*
		 * handle modules
		 */
		dp = driver;

		issued = FALSE;
		do	{
			mp = dp->opthdr;
			if (!(dp->flag & LOAD) ||
			   !(mp->flag & (NOTADRV | FUNMOD)))
				continue;

			if (QuietMode = break_hit())
				{
				printf("\n");
				return;
				}

			if (! issued)
				/*
				 * print heading for first module found
				 */
				{
				issued = TRUE;
				printf("\n     ----module----\n");
				/*       \n     DIRSIZ__LENGTH */
				}

			printf("     %s\n", dp->name);
			}
			while (dp = dp->next);
		}

	printf("\n");
	}

#if DEBUG1e
/*
 * Print_driver()
 *
 * Print the kernel and driver linked-list
 */

static void print_master();
static void print_expression();
static char *print_flag();

 void
print_driver()
	{PROGRAM(print_driver)

	register struct driver *dp;
	register int i;


	printf("\nKernel:\n");

	if (kernel != NULL)
		print_master(kernel->opthdr);

	printf("\nDriver linked-list:\n");

	if ((dp = driver) == NULL || dp->next == driver)
		return;

	do	{
		printf("%9s  flag=%4X  #C=%d  #M=%d  maj(sys)=", dp->name, dp->flag, dp->nctl, dp->int_major);

		for (i=0; i<dp->nctl; ++i)
			printf("0x%X(0x%X)%s", dp->maj[i], dp->sys_bits[i], (i+1==dp->nctl)?"":",");
		printf("\n           #syms=%D   symptr=0x%lX\n", dp->nsyms, dp->symptr);

		printf("           text: vaddr=0x%6lX sz=0x%lX sptr=0x%lX #rel=%d rptr=0x%lX\n",
			dp->shdr[0].s_vaddr, dp->shdr[0].s_size, dp->shdr[0].s_scnptr, dp->shdr[0].s_nreloc, dp->shdr[0].s_relptr);
		printf("           data: vaddr=0x%6lX sz=0x%lX sptr=0x%lX #rel=%d rptr=0x%lX\n",
			dp->shdr[1].s_vaddr, dp->shdr[1].s_size, dp->shdr[1].s_scnptr, dp->shdr[1].s_nreloc, dp->shdr[1].s_relptr);
		printf("           bss:  vaddr=0x%6lX sz=0x%lX\n", dp->shdr[2].s_vaddr, dp->shdr[2].s_size);

		print_master(dp->opthdr);
		}
		while (dp = dp->next);
	}



/*
 * Print_master()
 *
 * Print the master file optional header built by mkboot(1M)
 */
 static
 void
print_master(master)
	register struct master *master;
	{PROGRAM(print_master)

	register int i, j;


	if (master == NULL)
		return;

	printf("           flag=");
	if (master->vec)
		printf("%d %s\n", master->vec, print_flag(master->flag));
	else
		printf("%s\n", print_flag(master->flag));

	if (! (master->flag & KERNEL))
		{
		printf("           nvec=%d  prefix=%s  software=%d  ndev=%d  ipl=%d\n",
			master->nvec, master->prefix, master->soft,
			master->ndev, master->ipl);

		if (master->ndep)
			{
			register struct depend *dp = (struct depend *) POINTER(master->o_depend, master);
			for (i=0; i<master->ndep; ++i, ++dp)
				printf("           dependency=%s\n", POINTER(dp->name,master));
			}
		}

	if (master->nparam)
		{
		char name[PARAMNMSZ+1];
		register struct param *pp = (struct param *) POINTER(master->o_param, master);
		for (i=0; i<master->nparam; ++i, ++pp)
			{
			if (pp->name[0] == '\0')
				continue;
			printf("           parameter: %s = ",  strncat(strcpy(name,""),pp->name,PARAMNMSZ));
			if (pp->type == '"')
				printf("\"%s\"\n", POINTER(pp->value.string, master));
			else
				printf("0x%X\n", pp->value.number);
			}
		}

	if (! (master->flag & KERNEL))
		{
		if (master->nrtn)
			{
			static char *id[] = { "", "nosys", "nodev", "true", "false", "fsnull", "fsstray", "nopkg", "noreach" };
			register struct routine *rp = (struct routine *) POINTER(master->o_routine, master);
			for (i=0; i<master->nrtn; ++i, ++rp)
				printf("           routine %s() {%s}\n", POINTER(rp->name,master), id[rp->id]);
			}
		}

	if (master->nvar)
		{
		register struct variable *vp = (struct variable *) POINTER(master->o_variable, master);

		for (i=0; i<master->nvar; ++i, ++vp)
			{
			printf("           variable %s", POINTER(vp->name, master));
			if (vp->dimension)
				{
				printf("[");
				print_expression((union element *) POINTER(vp->dimension, master));
				printf("]");
				}
			printf("(0x%X)\n", vp->size);
			if (vp->ninit)
				{
				static char *type[] = { "0x%X", "c", "s", "i", "l", "%dc" };
				register struct format *fp = (struct format *) POINTER(vp->initializer, master);
				for (j=0; j<vp->ninit; ++j,++fp)
					{
					printf("                 ={ %s", "%");
					printf(type[fp->type&FTYPE], ((fp->type&FTYPE)!=FSTRING)? fp->value : fp->strlen);
					if (fp->type & FEXPR)
						{
						printf(" expression=");
						print_expression((union element *) POINTER(fp->value, master));
						printf(" }\n");
						continue;
						}
					if (fp->type & FSKIP)
						{
						printf(" }\n");
						continue;
						}
					printf(" 0x%X }\n", fp->value);
					}
				}
			}
		}
	}


/*
 * Print_expression(expression)
 *
 * Print an expression
 */
 static
 void
print_expression(expression)
	register union element *expression;
	{

	static union element *xp;
	register int temp;
	char c[2];

	if (expression == NULL)
		expression = xp;

	switch (c[1]='\0', c[0]=expression->operator)
		{
		char name[PARAMNMSZ+1];
	case '+':
	case '-':
	case '*':
	case '/':
		xp = XBUMP(expression,operator);
		print_expression((union element *)NULL);
		printf(c);
		print_expression((union element *)NULL);
		break;
	case '>':
	case '<':
		printf((c[0]=='<')? "min(" : "max(");
		xp = XBUMP(expression,function);
		print_expression((union element *)NULL);
		printf(",");
		print_expression((union element *)NULL);
		printf(")");
		break;
	case 'C':
	case 'D':
	case 'M':
		printf("#%s", c);
		if (expression->nC[1])
			printf("(%s)", expression->nC+1);
		xp = XBUMP(expression,nC);
		break;
	case '#':
	case '&':
		printf("%s%s", c, expression->size_of+1);
		xp = XBUMP(expression,size_of);
		break;
	case 'I':
		printf("%s", strncat(strcpy(name,""),expression->identifier+1,PARAMNMSZ));
		xp = XBUMP(expression,identifier);
		break;
	case '"':
		printf("\"%s\"", expression->string+1);
		xp = XBUMP(expression,string);
		break;
	case 'N':
		temp = ((expression->literal[1]<<8 | expression->literal[2] & 0xFF)<<8 | expression->literal[3] & 0xFF)<<8 | expression->literal[4] & 0xFF;
		printf("%d", temp);
		xp = XBUMP(expression,literal);
		break;
		}
	}


/*
 * print_flag(flag)
 *
 * Print the flags symbolically
 */
 static
 char *
print_flag(flag)
	register unsigned short flag;
	{
	static char buffer[80];

	strcpy(buffer, "");

	if (flag == 0)
		return("none");

	if (flag & KERNEL)
		strcat(buffer, ",KERNEL");

	if (flag & ONCE)
		strcat(buffer, ",ONCE");

	if (flag & REQ)
		strcat(buffer, ",REQ");

	if (flag & BLOCK)
		strcat(buffer, ",BLOCK");

	if (flag & CHAR)
		strcat(buffer, ",CHAR");

	if (flag & FUNDRV)
		strcat(buffer, ",FUNDRV");

	if (flag & REQADDR)
		strcat(buffer, ",REQADDR");

	if (flag & TTYS)
		strcat(buffer, ",TTYS");

	if (flag & SOFT)
		strcat(buffer, ",SOFT");

	if (flag & FUNMOD)
		strcat(buffer, ",FUNMOD");

	if (flag & NOTADRV)
		strcat(buffer, ",NOTADRV");

	if (flag & FSTYP)
		strcat(buffer, ",FSTYP");

	return(buffer+1);
	}
#endif

/*
 * searchdriver(name)
 *
 * Search the driver linked-list to locate driver `name'; when found, return
 * the pointer to the struct driver entry; if not found return NULL.
 */
 static
 struct driver *
searchdriver(name)
	char *name;
	{PROGRAM(searchdriver)

	register struct driver *dp;

	if ((dp=driver) != NULL)
		do	{
			if (0 == strcmp(dp->name,name))
				return(dp);
			}
			while (dp = dp->next);

	return(NULL);
	}

/*
 * Include(dname, number)
 *
 * Mark driver `dname' to be included for `number' more controllers.
 *
 * If the driver was found in the EDT, then `number' is ignored since the
 * number of controllers is already determined.  Likewise, if the driver
 * is a required driver, then the number of controllers must be set to one,
 * so `number' is ignored.
 *
 * If the driver was not found in the EDT, then it cannot be included
 * unless it is a software driver, or it is just an independent module.
 */
 void
include(dname, number)
	register char *dname;
	int number;
	{PROGRAM(include)

	register struct driver *dp;
	register struct master *mp;

	if ((dp=searchdriver(dname)) == NULL)
		/* INCLUDE: <dname>; driver not found */
		error(ER18, dname);
	else
		{
		if (dp->flag & EXCLUDE)
			{
			/* INCLUDE: <dname>; driver is EXCLUDED */
			error(ER19, dname);
			return;
			}

		if (dp->flag & INEDT)
			/*
			 * it will be included based on number of times in EDT
			 */
			{
			dp->flag |= INCLUDE;
			return;
			}

		mp = dp->opthdr;
		if (mp->flag & (NOTADRV | FUNMOD))
			{
			dp->flag |= INCLUDE;
			dp->nctl += number;
			return;
			}

		if (! (mp->flag & SOFT))
			/* INCLUDE: <dname>; device not equipped */
			error(ER20, dname);
		else
			{
			dp->flag |= INCLUDE;

			if (! (mp->flag & REQ))
				dp->nctl += number;
			}
		}
	}

/*
 * Exclude(dname)
 *
 * Mark driver `dname' to be excluded or ignored
 */

void
exclude(dname)
register char *dname;
{PROGRAM(exclude)

	register struct driver *dp;

	if ((dp=searchdriver(dname)) == NULL)
		/*
		 * this may be an EDT entry that is to be ignored
		 */
		ignore(dname);
	else{
		if (dp->flag & INCLUDE)
			/* EXCLUDE: <dname>; driver is INCLUDED */
			error(ER21, dname);
		else
			dp->flag |= EXCLUDE;
	}
}

/*
 * Ignore(name)
 *
 * Remember this EDT device name so that ignoredt() can respond with the correct
 * answer.  This routine is called when the /etc/system EXCLUDE lines are being
 * processed and there is no driver in the driver linked-list for this name.
 *
 * The EXCLUDE lines were not available at the time the driver linked-list was
 * being built, so EDT entries were just bypassed if there was no corresponding
 * driver found in /boot -- it could not be determined whether a driver was
 * missing or the EDT entry was to be ignored.
 *
 * Later, the EDT will be scanned again, and ignoredt() called in order to catch
 * the EDT entries to be ignored.  Diagnostics will then be issued for missing
 * drivers.
 */

struct	ignore
	{
	struct ignore	*next;
	char		name[DIRSIZ+1];
	};

static struct ignore *edtlist;

 void
ignore(name)
	char *name;
	{PROGRAM(ignore)

	register struct ignore *ip;

	if ((ip=(struct ignore*)malloc(sizeof(*ip))) == NULL)
		panic("No memory for EXCLUDE list");

	ip->next = edtlist;
	strncat(strcpy(ip->name,""), name, sizeof(ip->name));

	edtlist = ip;
	}



/*
 * ignoredt(name)
 *
 * Answer the question: should this entry from the EDT be ignored?
 * Return TRUE if so, FALSE if it is not to be ignored.
 */
 static
 boolean
ignoredt(name)
	char *name;
	{PROGRAM(ignoredt)

	register struct ignore *ip;

	for (ip=edtlist; ip!=NULL; ip=ip->next)
		if (0 == strcmp(ip->name,name))
			return(TRUE);

	return(FALSE);
	}

/*
 * Dependency(pdriver)
 *
 * Driver *pdriver has dependencies.  Find them in the driver linked-list, mark
 * them to be loaded, and follow their dependencies.
 */
 static
 void
dependency(pdriver)
	register struct driver *pdriver;
	{PROGRAM(dependency)

	register struct driver *dp;
	register struct master *m, *mp = pdriver->opthdr;
	register struct depend *dep;
	register count;
	char *name;

	dep = (struct depend*) POINTER(mp->o_depend, mp);

	for (count=0; count<mp->ndep; ++count, ++dep)
		{

		if ((dp=searchdriver(name=(char*)POINTER(dep->name,mp))) == NULL)
			{
			/* <pdriver->name>: dependent driver <name> not available */
			error(ER22, pdriver->name, name);
			continue;
			}

		if (dp->flag & LOAD)
			/*
			 * already marked to be loaded
			 */
			continue;

		if (dp->flag & EXCLUDE)
			/*
			 * hey! this driver was excluded
			 */
			{
			/* <pdriver->name>: dependent driver <name> is EXCLUDED */
			error(ER23, pdriver->name, name);
			continue;
			}

		m = dp->opthdr;
		if (!((m->flag & (SOFT|NOTADRV)) ||
		    ((m->flag & (CHAR | BLOCK | FUNMOD | FUNDRV)) == FUNMOD)) &&
		   !(dp->flag & (INEDT|ISEBUS)))
			/*
			 * driver is not a software driver (ie. it is a
			 * hardware driver) but the hardware does not exist
			 */
			{
			/* <pdriver->name>: device not equipped for dependent driver <name> */
			error(ER24, pdriver->name, name);
			continue;
			}

		dp->flag |= LOAD;

		if (m->ndep > 0)
			/*
			 * follow the dependency chain
			 */
			dependency(dp);

		if ((m->flag & (SOFT|NOTADRV) ||
		     ((m->flag & (CHAR | BLOCK | FUNMOD | FUNDRV)) == FUNMOD)) && 
		    ! (dp->flag & (INEDT|ISEBUS)) && dp->nctl == 0)
			/*
			 * make sure that #C is set if not done already
			 */
			dp->nctl = 1;
		}
	}

/*
 * eval(expression, dp)
 *
 * Evaluate a prefix polish expression string.  The `expression' must be a
 * pointer to the beginning of the string.  The current driver structure
 * element is pointed to by `dp'.
 */
 long
eval(expression, dp)
	register union element *expression;
	register struct driver *dp;
	{PROGRAM(eval)

	register SYMBOL *sp;
	register long temp;

	static union element *xp;

	if (expression == NULL)
		expression = xp;

	switch (expression->operator)
		{
	/*
	 * binary arithmetic operators
	 */
	case '+':
		xp = XBUMP(expression,operator);
		temp = eval((union element *)NULL, dp);
		return(temp + eval((union element *)NULL,dp));
	case '-':
		xp = XBUMP(expression,operator);
		temp = eval((union element *)NULL, dp);
		return(temp - eval((union element *)NULL,dp));
	case '*':
		xp = XBUMP(expression,operator);
		temp = eval((union element *)NULL, dp);
		return(temp * eval((union element *)NULL,dp));
	case '/':
		/*
		 * note: division by zero is allowed, and result is zero
		 */
		xp = XBUMP(expression,operator);
		temp = eval((union element *)NULL, dp);

			{
			register long divisor = eval((union element *)NULL, dp);

			if (divisor == 0)
				return(0);
			else
				return(temp / divisor);
			}
	/*
	 * leaf - builtin fuctions: min, max
	 */
	case '<':
		xp = XBUMP(expression,function);
		temp = eval((union element *)NULL, dp);
		return(min(temp,eval((union element *)NULL,dp)));
	case '>':
		xp = XBUMP(expression,function);
		temp = eval((union element *)NULL,dp);
		return(max(temp,eval((union element *)NULL,dp)));
	/*
	 * leaf - builtin variables
	 */
	case 'C':
		xp = XBUMP(expression,nC);
		if (expression->nC[1] == '\0')
			return(dp->nctl);
		else
			{
			register struct driver *d;
			if ((d=searchdriver(&expression->nC[1])) != NULL)
				return(d->nctl);

			/* <dp->name>: data initializer #C(<&expression->nC[1]>) unknown; zero assumed */
			error(ER25, dp->name, &expression->nC[1]);
			return(0);
			}
	case 'S':
		xp = XBUMP(expression,nS);
		if (expression->nS[1] == '\0')
			return(dp->ntc_lu);
		else
			{
			register struct driver *d;
			if ((d=searchdriver(&expression->nS[1])) != NULL)
				return(d->ntc_lu);

			/* <dp->name>: data initializer #S(<&expression->nS[1]>) unknown; zero assumed */
			error(ER90, dp->name, &expression->nS[1]);
			return(0);
			}
	case 'D':
		xp = XBUMP(expression,nD);
		if (expression->nD[1] == '\0')
			return(dp->opthdr->ndev);
		else
			{
			register struct driver *d;
			if ((d=searchdriver(&expression->nD[1])) != NULL)
				return(d->opthdr->ndev);

			/* <dp->name>: data initializer #D(<&expression->nD[1>) unknown; zero assumed */
			error(ER26, dp->name, &expression->nD[1]);
			return(0);
			}
	case 'M':
		xp = XBUMP(expression,nM);
		if (expression->nM[1] == '\0')
			return(dp->int_major);
		else
			{
			register struct driver *d;
			if ((d=searchdriver(&expression->nM[1])) != NULL)
				return(d->int_major);

			/* <dp->name>: data initializer #M(<&expression->nM[1>) unknown; zero assumed */
			error(ER27, dp->name, &expression->nM[1]);
			return(0);
			}
	/*
	 * leaf - address of
	 */
	case '&':
		if ((sp=Ksym_name(&expression->address_of[1])) == NULL)
			sp = Xsym_name(&expression->address_of[1]);

		if (! (sp->flag & DEFINED))
			if (! routine(&expression->address_of[1]))
				{
				/* <dp->name>: data initializer &<&expression->address_of[1])> cannot be resolved*/
				error(ER28, dp->name, &expression->address_of[1]);

				define(&expression->address_of[1], 0L);
				}

		xp = XBUMP(expression,address_of);
		return(sp->value);
	/*
	 * leaf - size of
	 */
	case '#':
			{
			struct driver *d;

			d = (struct driver*)kernel;
			do	{
				register struct master *mp = d->opthdr;
				register struct variable *vp;

				vp = (struct variable *) POINTER(mp->o_variable,mp);
				for (temp=0; temp<mp->nvar; ++temp, ++vp)
					{
					if (0 == strcmp(&expression->size_of[1],(char *)POINTER(vp->name,mp)))
						{
						xp = XBUMP(expression,size_of);
						return(vp->size);
						}
					}
				}
				while (d = d->next);

			/* <dp->name>: data initializer #<&expression->size_of[1> unknown; zero assumed */
			error(ER29, dp->name, &expression->size_of[1]);

			xp = XBUMP(expression,size_of);
			return(0);
			}
	/*
	 * leaf - string
	 */
	 case '"':
		xp = XBUMP(expression,string);
		return(alloc_string(&expression->string[1]));
	/*
	 * leaf - identifier
	 */
	case 'I':
		{
		register struct param *pp;
		char name[PARAMNMSZ+1];

		xp = XBUMP(expression,identifier);

		if ((pp=searchparam(&expression->identifier[1])) != NULL)
			{
			if (pp->type == '"')
				return(alloc_string(*(char**)POINTER(pp->value.string,pp)));
			else
				return(pp->value.number);
			}

		/* <dp->name>: data initializer <&expression->identifier[1]> unknown; zero assumed */
		error(ER30, dp->name, strncat(strcpy(name,""),&expression->identifier[1],PARAMNMSZ));
		return(0);
		}
	/*
	 * leaf - literal value
	 */
	case 'N':
		temp = ((expression->literal[1]<<8 | expression->literal[2])<<8 | expression->literal[3])<<8 | expression->literal[4];
		xp = XBUMP(expression,literal);
		return(temp);
	default:
		/* Undefined expression element */
		error(ER3);
		}
	/*NOTREACHED*/
	}

/*
 * searchparam(name)
 *
 * Search the kernel and driver linked-list to locate a parameter `name'; when
 * found, return the pointer to a static struct param: if the value is a string,
 * then the string offset is modified to an offset from the struct param which
 * points to a character pointer which points to the actual string:
 *
 *		if (p->type == '"')
 *			*(char**)POINTER(p->value.string,p) -> the string
 *
#ifdef u3b15
 * If the parameter name is not found return NULL.
#endif
#ifdef u3b2
 * If the parameter name is not found, return NULL unless the parameter name
 * is "NBUF".  In this case, return a value which is derived from the size of
 * memory.
#endif
 */
 static
 struct param *
searchparam(name)
	register char *name;
	{PROGRAM(searchparam)

	register struct driver *dp;
	register struct master *mp;
	register struct param *pp;
	register i;
	static struct
		{
		struct param	param;
		char		*string;
		}
		pentry;

	dp = (struct driver *) kernel;

	do	{
		mp = dp->opthdr;

		pp = (struct param *) POINTER(mp->o_param,mp);

		for (i=0; i<mp->nparam; ++i,++pp)
			if (0 == strncmp(pp->name,name,PARAMNMSZ))
				{
				pentry.param = *pp;

				if (pp->type == '"')
					{
					pentry.string = (char*) POINTER(pp->value.string,mp);
					pentry.param.value.string = OFFSET(&pentry.string, &pentry.param);
					}

				return(&pentry.param);
				}
		}
		while (dp = dp->next);

#ifdef u3b2
	if (0 == strcmp(name,"NBUF"))
		/*
		 * the number of buffers depends upon the size of memory for
		 * the 3B2
		 */
		{

#define	K		1024
#define	M		K*K

#define	DIM(array)	(sizeof(array)/sizeof(array[0]))

		/*
		 * use "nbuf" buffers if the highest address of system memory
		 * is at least "memory"
		 */
		struct nbuf_vs_memory
			{
			int	nbuf;	/* number of buffers */
			address	memory;	/* upper bound on memory */
			};

		extern address maxmem;
		static struct nbuf_vs_memory n_vs_m[] ={
							{  50, MAINSTORE+  M/2 },
							{ 100, MAINSTORE+  M   },
							{ 250, MAINSTORE+2*M   },
							{ 400, MAINSTORE+3*M   },
							{ 600, MAINSTORE+4*M   },
						       };


		for (i=0; ; ++i)
			switch (i)
				{
			default:
				if (maxmem <= n_vs_m[i].memory)
					{
			case DIM(n_vs_m)-1:
					pentry.param.type = 'N';
					pentry.param.value.number = n_vs_m[i].nbuf;
					return(&pentry.param);
					}
				}
		}
#endif

	return(NULL);
	}

/*
 * loadunix()
 *
 *	This routine loads the boot program specified by `bootprogram.path' into
 *	memory and branches to it
 */

CONDITION ABORT ={ "ABORT" };

 void
loadunix()
	{PROGRAM(loadunix)

	extern boolean MagicMode;
	extern boolean	LoadMap;
	register struct driver *dp;
	register struct master *mp;
	register i;
 	dev_t tdev;
	int fd = -1;
	int number_drivers;
	int b_major, c_major, bc_major;
	int (*entry)();
	FILHDR fhdr;
	struct stat statbuf;
	unsigned char soft_major[128];

#if TEST
	elapsed("Load unix begun");
#endif

	/*
	 * if the /etc/system file name was found by findsystem(), then it must
	 * be parsed to extract the boot program name (among other things); but
	 * before fsystem() can be called, the driver linked-list must be built.
	 */
	if (etcsystem[0])
		{
		FILE *stream;

		/*
		 * build driver linked-list
		 */
		findrivers();

		if ((fd=open(etcsystem)) == -1)
			{
			/* <etcsystem>: perror() message */
			error(ER7, etcsystem);
			return;
			}

		fsystem(stream=fdopen(fd));
		close(fdclose(stream));
		}

	/*
	 * if the boot program name was not specified in /etc/system, it has
	 * to be gotten now
	 */
	while (! bootprogram.path[0])
		system("BOOT:?");

	/*
	 * open the boot program file, and figure out what kind of object
	 * file it is
	 */
	if (stat(bootprogram.path,&statbuf) == -1 || (fd=open(bootprogram.path)) == -1)
		{
		/* <bootprogram.path>: perror() message */
		error(ER7, bootprogram.path);
		return;
		}

	if (! (statbuf.st_mode & (S_IEXEC|S_IEXEC>>3|S_IEXEC>>6)))
		/* <bootprogram.path>: warning: not executable */
		error(ER31, bootprogram.path);

	ON(IOERROR)
		goto exit;

	/*
	 * Read file header and verify it.
	 */
	read_and_check(fd, (char*)&fhdr, FILHSZ);

	if (fhdr.f_magic != FBOMAGIC)
		{
		/* <bootprogram.path>: not MAC32 magic */
		error(ER32, bootprogram.path);
		goto exit;
		}

	bootprogram.timestamp = fhdr.f_timdat;

#if DEBUG1
	if (prt[_LOADUNIX])
		{
		printf("\nFile header:\n");
		printf("     f_magic = 0%o\n", fhdr.f_magic);
		printf("     f_nscns = %d\n", fhdr.f_nscns);
		printf("     f_timdat= 0x%lX\n", fhdr.f_timdat);
		printf("     f_symptr= 0x%lX\n", fhdr.f_symptr);
		printf("     f_nsyms = %D\n", fhdr.f_nsyms);
		printf("     f_opthdr= 0x%X\n", fhdr.f_opthdr);
		printf("     f_flags = 0x%X\n", fhdr.f_flags);
		}
#endif

	if (fhdr.f_nscns == 0)
		{
		/* <bootprogram.path>: no section headers */
		error(ER33, bootprogram.path);
		goto exit;
		}

	/*
	 * Allocate kernel structure and read optional header if present;
	 * note that the driver linked list may not yet be allocated so it
	 * cannot be linked to the kernel list yet.
	 */
	if ((kernel=(struct kernel*)malloc((unsigned int)(sizeof(struct kernel)+max((long)fhdr.f_opthdr,(long)sizeof(struct master))))) == NULL)
		{
		printf("No memory for kernel optional header\n");
		goto exit;
		}

	kernel->opthdr = mp = (struct master*) (kernel + 1);
	kernel->flag = 0;
	kernel->nctl = 0;
	kernel->int_major = 0;
	kernel->name = bootprogram.path;

	read_and_check(fd, (char*)mp, fhdr.f_opthdr);

	if (fhdr.f_opthdr == 0 || mp->magic != MMAGIC)
		{
		mp->flag = KERNEL;
		mp->vec = 0;
		mp->ndev = 0;
		mp->ndep = 0;
		mp->nparam = 0;
		mp->nrtn = 0;
		mp->nvar = 0;
		}
	else
		if (! (mp->flag & KERNEL))
			{
			/* <bootprogram.path>: not flagged as KERNEL by mkboot(1M) */
			error(ER47, bootprogram.path);
			goto exit;
			}

	close(fd);
	fd = -1;

	ON(ABORT)
		goto exit;

	if (fhdr.f_flags & F_EXEC)
		/*
		 * executable; must be absolute file
		 */
		{

		/*
		 * load the file into memory
		 */
		auto_config = FALSE;		/* mkunix will not be done */

		entry = absolute(NULL);

		}

	else
		/*
		 * Not F_EXEC; must be auto-configurable UNIX
		 */
		{

		auto_config = TRUE;		/* mkunix will be executed unless
						 * magic mode was run
						 */

		/*
		 * if /etc/system file was not processed yet, then it was not
		 * provided or it does not exist; therefore, the driver linked-list
		 * must still be built, and system parameters must be prompted
		 */
		if (! etcsystem[0])
			{
			findrivers();

			if (driver->next != driver)
				system("INCLUDE:?\nEXCLUDE:?");
			}

		if (driver->next == driver)
			/*
			 * no driver linked-list could be built; self-config cannot be done:
			 * No drivers available, absolute BOOT program must be used
			 */
			{
			error(ER34);
			return;
			}

		/*
		 * link the driver linked-list to the kernel data structure
		 */
		kernel->next = driver;

		/*
		 * check the parameters for multiply defined values
		 */
		check_param();

		/*
		 * go through the EDT again now that the /etc/system file has
		 * been processed; the EXCLUDE entries will be caught here for
		 * those EDT entries which did not have a corresponding driver
		 * in /boot
		 */
		edtscan(EDT_START, 0, catch);

		/* Now that the etc/system file has been processed, scan
		 * the edt for HA devices. EDT entries with edt->indir_dev
		 * set indicate a HA device
		 */
		edtscan(EDT_START, 0, fndxbus);

#ifdef u3b2
		/*
		 * if the system file was provided AND the system devices were not
		 * specified AND the boot device contained a vtoc AND the vtoc
		 * contained flagged partitions for root or swap, THEN use these
		 * defaults:
		 *
		 *	rootdev - boot device
		 *	pipedev - rootdev
		 *	swapdev - boot device
		 */
		if (etcsystem[0] && VTOC_devname && (dp=searchdriver(VTOC_devname)) != NULL && (mp=dp->opthdr)->flag & BLOCK)
			{
			if (mp->flag & SOFT)
				/*
				 * major number is not the board slot
				 */
				VTOC_major = mp->soft;

			if (rootdev == NODEV && VTOC_root != -1) {
				rootdev = makedev(VTOC_major, VTOC_minor * 16 + VTOC_root);
			}
			if (pipedev == NODEV && rootdev != NODEV)
				pipedev = rootdev;
			if (swapdev == NODEV && VTOC_swap != -1)
				{
				swapdev = makedev(VTOC_major, VTOC_minor * 16 + VTOC_swap);
				swplo = 0;
				nswap = VTOC_nswap;
				}
			}
#endif

  		/*
		 * If a system device entry was detected in the VTOC
		 * AND the device entry has been assigned a value AND
		 * the VTOC physical location is not in either of
		 * the mirror device specifications AND
		 * the value does not agree with the VTOC (i.e. it was
		 * assigned from the system file), print a warning.
		 *
		 * This condition can occur for rootdev and pipedev
		 * since they are usually the same.  It could also occur
		 * for swapdev if the swap device is the root mirror
		 * device (since rootdev is the only device initialized
		 * for mirroring at boot time).
		 */

		tdev = makedev(VTOC_major, VTOC_minor * 16 + VTOC_root);
		if (VTOC_root != -1 && rootdev != NODEV &&
			 mirrordev[0] != tdev &&
			 mirrordev[1] != tdev &&
			 rootdev != tdev)
				error(ER101, major(rootdev), minor(rootdev));

		if (VTOC_root != -1 && pipedev != NODEV &&
			 mirrordev[0] != tdev &&
			 mirrordev[1] != tdev &&
			 pipedev != tdev)
				error(ER104, major(pipedev), minor(pipedev));

		tdev = makedev(VTOC_major, VTOC_minor * 16 + VTOC_swap);
		if (VTOC_swap != -1 && swapdev != NODEV &&
			 mirrordev[0] != tdev &&
			 mirrordev[1] != tdev &&
			 swapdev != tdev)
				error(ER102, major(swapdev), minor(swapdev));

#ifdef u3b15
		if (VTOC_dump != -1 && dumpdev != NODEV &&
			 (makedev(VTOC_major, VTOC_minor * 16 +
			 VTOC_dump) != dumpdev))
				error(ER103, major(dumpdev), minor(dumpdev));

#endif

		/*
		 * make sure we have everything we need
		 */
		while (rootdev == NODEV)
			system("ROOTDEV:?");

		while (pipedev == NODEV)
			system("PIPEDEV:?");

#ifdef u3b15
		while (dumpdev == NODEV)
			system("DUMPDEV:?");
#endif

		while (swapdev == NODEV || swplo == -1 || nswap == -1)
			system("SWAPDEV:? ? ?");


		/*
		 * if the LBE driver does not exist, a LBE is not installed, or
		 * the LBE driver has been EXCLUDED, then devices on the LBE
		 * cannot be supported
		 */
		if ((dp=searchdriver("LBE")) == NULL || ! (dp->flag & INEDT) || dp->flag & EXCLUDE)
			/*
			 * remove any devices on a LBE
			 */
			{
			register j;

			dp = driver;
			do	{
				if (dp->flag & EXCLUDE)
					continue;

				if (! (dp->flag & INEDT))
					continue;

				for (i=j=0; i<dp->nctl; ++i)
					{
					if (ONLBE(dp->maj[i]))
						{
						/* <dp->name>: device not configured (LBE <n>, board code <n>) */
						error(ER35, dp->name, LBELBA(dp->maj[i]), LBEELB(dp->maj[i]));
						}
					else
						dp->maj[j++] = dp->maj[i];
					}

				if ((dp->nctl = j) == 0)
					dp->flag |= EXCLUDE;
				}
				while (dp = dp->next);
			}

		/*
		 * determine all drivers to be loaded
		 */
		dp = driver;
		do	{
			if((mp=dp->opthdr)->flag & REQ)
				{
				if(dp->flag & EXCLUDE)
					{
					/* <dp->name>: required driver is EXCLUDED */
					error(ER36, dp->name);
					continue;
					}

				dp->flag |= LOAD;
				if(dp->nctl < 1)
					dp->nctl = 1;
				}

			if(dp->flag & EXCLUDE)
				continue;

			if(dp->flag & (INEDT|INCLUDE|ISEBUS))
				dp->flag |= LOAD;

			if(dp->flag & LOAD && mp->ndep > 0)
				dependency(dp);
			}
			while (dp = dp->next);

		/*
		 * Assign the internal major numbers.  This is a two pass approach,
		 * first the drivers which are both BLOCK and CHAR are assigned numbers
		 * then the remaining drivers are assigned.  This will minimize the size
		 * of the character and block device switch tables.
		 */

		for (i=0; i<128; i++)
			soft_major[i] = 0;

		for (bc_major=0, i=0; i<2; b_major=c_major=bc_major, ++i)
			{
			dp = driver;

			do	{
				if (! (dp->flag & LOAD))
					continue;

				mp = dp->opthdr;

				
				if (mp->flag & SOFT && i == 0)
					if (soft_major[mp->soft] != 0){
						printf("Software driver %s has duplicate major number %d, check master.d entry\n",dp->name,mp->soft);
						printf("Driver %s will not be loaded\n",dp->name);
						dp->flag &= ~LOAD;
						continue;
					} else
						soft_major[mp->soft] = mp->soft;
				if (i == 0)
					{
					if ((mp->flag & (BLOCK|CHAR)) == (BLOCK|CHAR))
						dp->int_major = bc_major++;
					}
				else
					{
					if((mp->flag & (BLOCK|CHAR)) == BLOCK)
						dp->int_major = b_major++;
					else
						if ((mp->flag & (BLOCK|CHAR)) == CHAR || mp->flag & FUNDRV)
							dp->int_major = c_major++;
					}
				}
				while (dp = dp->next);
			}

		/*
		 * Compute cdevcnt, bdevcnt, and fmodcnt; also count the total 
		 * number of drivers to be loaded, and interrupt routines that 
		 * will be needed
		 */

		number_drivers = 0;

		dp = driver;
		do	{

			if (dp->flag & LOAD)
				{
				++number_drivers;

				driver_text += dp->shdr[0].s_size;

				if ((mp=dp->opthdr)->flag & ONCE && dp->nctl != 1)
					{
					/* <dp->name>: flagged as ONCE only; #C set to 1 */
					error(ER37, dp->name);
					dp->nctl = 1;
					}

				if (mp->flag & FSTYP) {
					++fstypcnt;
					++fsincnt;
					++nfstyp;
					continue;
				}

				if (mp->flag & NOTADRV)
					continue;

				if (mp->flag & FUNMOD) {
					++fmodcnt;
					if (!(mp->flag & (CHAR | BLOCK | FUNDRV)))
						continue;
				}

				if (mp->flag & (CHAR | FUNDRV))
					cdevcnt = max((long)cdevcnt, (long)(dp->int_major));
				if (mp->flag & BLOCK)
					bdevcnt = max((long)bdevcnt, (long)(dp->int_major));

				interrupts += dp->nctl * mp->nvec;
				}
			}
			while (dp = dp->next);

		++fstypcnt;
		++fsincnt;
		++nfstyp;
		++cdevcnt;
		++bdevcnt;

#if DEBUG1
		if (prt[_LOADUNIX])
			{
			printf("%d interrupt routines required; cdevcnt=%d  bdevcnt=%d fmodcnt=%d fstypcnt=%d fsincnt=%d \n", interrupts, cdevcnt, bdevcnt, fmodcnt, fstypcnt, fsincnt);

			shell();
			}
#endif

		/*
		 * Print configuration table if auto-boot switch is off
		 */
		if (! ISAUTO)
			print_configuration();

		/*
		 * allocate the space for the load map array
		 */
		alloc_loadmap((unsigned)(fhdr.f_nscns + 3*number_drivers));

		/*
		 * do the dirty work; load the kernel and all drivers
		 */
		entry = relocatable(&fhdr);

		/*
		 * Print load map if auto-boot switch is off
		 */
		if (! ISAUTO && LoadMap)
			print_loadmap();

		}

#if TEST
	elapsed("UNIX loaded");

#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	/*
	 * CALL UNIX!!!!
	 *
	 * A single parameter is passed which indicates whether or not an
	 * auto-config boot was done.
	 */
	if (MagicMode)
		{
		printf("\
You are standing inside of a large unexecuted %s.  The only exit\n\
you see is at 0x%lX.\n",
			bootprogram.path, entry);
		RUNFLG = VECTOR;
		restart();
		}
	else
		(*entry)(auto_config == TRUE);


	/*
	 * Error exits; cleanup and return
	 */
exit:
	if (fd != -1)
		close(fd);
	}

/*
 * Catch(edtp, lba, elb)
 *
 * Catch the EXCLUDE entries in the EDT by checking each entry
 * in the EDT against ignoredt().
 */
 static
 void
catch(edtp, lba, elb)
	register struct edt *edtp;
	register int lba;
	int elb;
	{PROGRAM(catch)

#ifdef u3b15
	/*
	 * ignore IOA controlled devices
	 */
	if (edtp->ioa_edti != 0)
		return;
#endif

	if (searchdriver(edtp->dev_name) == NULL)
		/*
		 * there was no driver found for this device
		 */
		{
		if (! ignoredt(edtp->dev_name))
			{
			if (lba == 0)
				/* Driver not found for <edtp->dev_name> device (board code <n>) */
				error(ER38, edtp->dev_name, elb);
			else
				/* Driver not found for <edtp->dev_name> device (LBE <n>, board code <n>) */
				error(ER39, edtp->dev_name, lba, elb);
			}
		}
	}

/*
 * Check_param()
 *
 * Check all of the tunable parameter names for possibly multiply defined
 * values.  If any multiply defined values are found, issue an error message
 * and take steps to recover.
 */

struct	check
	{
	struct driver	*dp;
	struct param	*pp;
	};

 static
 void
check_param()
	{PROGRAM(check_param)

	register struct check *check, *cp, *Scp;
	register int nparam;
	boolean setzero;

	/*
	 * count the total number of parameters
	 */
	nparam = 0;

		{
		register struct driver *dp = (struct driver*) kernel;

		do	{
			nparam += dp->opthdr->nparam;
			}
			while (dp = dp->next);
		}

	/*
	 * allocate the check[] array
	 */
	if ((check=(struct check*)malloc(nparam*sizeof(struct check))) == NULL)
		panic("No memory for parameter checking\n");

	/*
	 * initialize the check[] array
	 */
		{
		register struct driver *dp = (struct driver*) kernel;
		register i;

		cp = check;

		do	{
			register struct master *mp = dp->opthdr;

			for (i=0; i<mp->nparam; ++i,++cp)
				{
				cp->dp = dp;
				cp->pp = &((struct param*) POINTER(mp->o_param,mp))[i];
				}
			}
			while (dp = dp->next);
		}

	/*
	 * sort the check[] array into alphabetical order by parameter name
	 */
		{
		register i, m;

		for (m=nparam/2; m>0; m/=2)
			{
			for (i=0; i<nparam-m; ++i)
				{
				cp = &check[i];

				if (strncmp(cp[0].pp->name,cp[m].pp->name,PARAMNMSZ) > 0)
					{
					struct check temp;

					temp = cp[m];

					do	{
						cp[m] = cp[0];
						}
						while ((cp-=m)>=check && strncmp(cp[0].pp->name,temp.pp->name,PARAMNMSZ)>0);

					cp[m] = temp;
					}
				}
			}
		}

	/*
	 * now search the check[] array for duplicate parameter names which
	 * have different values
	 */
	Scp = cp = check;

	while (cp < &check[nparam-1])
		{
		char name[PARAMNMSZ+1];
		register struct param *pp1;
		register struct check *last, *Icp;
		register struct driver *dp;

		if (strncmp((pp1=cp[0].pp)->name,cp[1].pp->name,PARAMNMSZ) != 0)
			{
			Scp = ++cp;
			continue;
			}

		/*
		 * a duplicate parameter name; compare the values
		 */
		if (checkcmp(&cp[0],&cp[1]))
			{
			++cp;
			continue;
			}

		/*
		 * values are not equal; Parameter <pp1->name> multiply defined
		 */
		error(ER70, strncat(strcpy(name,""),pp1->name,PARAMNMSZ));

		/*
		 * we have a situation where the parameter has been
		 * assigned different values, therefore we must attempt
		 * to resolve the conflict
		 *
		 * let the set of all duplicated parameters be {S}; then
		 *
		 * 	{S} = {I} + {X}
		 *
		 * where {I} is the subset of {S} of all parameters defined
		 * by drivers that are not excluded, and {X} is the subset
		 * of {S} of all parameters defined by drivers that are
		 * excluded
		 *
		 * step 1)
		 *	all parameters in {X} will be totally ignored
		 *
		 * step 2)
		 *	if the remaining parameters in {I} all have the
		 *	same value, then the conflict is resolved -- the
		 *	boot will proceed using this parameter value
		 *
		 * step 3)
		 *	since the remaining parameters in {I} still contain
		 *	the conflict, it is impossible to choose which
		 *	value is to be used; therefore, all of the values
		 *	are set to numeric zero
		 *
		 * unfortunately, the result of step 3 will probably be
		 * to cause a kernel panic or malfunction which would
		 * preclude any attempt to correct the problem in the
		 * /boot directory
		 *
		 * steps 1 and 2 provide the means to recover; diagnostic
		 * messages are printed which identify the offending
		 * drivers and the parameter values, therefore the
		 * operator need only re-boot and manually exclude the
		 * offending driver(s)
		 */

		Icp = NULL;

		/*
		 * we will only set parameter values to zero if there is
		 * a multiply defined parameter in {I}
		 */
		setzero = FALSE;

		for (last=Scp; last<&check[nparam] && strncmp(name,last[0].pp->name,PARAMNMSZ)==0; ++last)
			{
			if (! (last->dp->flag & EXCLUDE))
				/*
				 * we have a member of set {I}
				 */
				{
				if (Icp == NULL)
					/*
					 * remember the first member of {I}
					 */
					Icp = last;
				else
					/*
					 * compare the parameter value of all members of {I}
					 */
					if (! checkcmp(Icp,last))
						/*
						 * a multiply defined parameter in {I}
						 */
						setzero = TRUE;
				}
			}

		/*
		 * go through {S} and
		 *
		 *	a) print a diagnostic
		 *	b) ignore parameters from excluded drivers
		 *	c) set parameter values to zero if setzero==TRUE
		 */
		for (cp=Scp; cp < last; ++cp)
			{
			/*
			 * there are six unique messages that may be issued
			 * depending on:
			 *
			 *	parameter value - numeric or string
			 *	driver status - EXCLUDED or not
			 *	conflict resolved - yes or no (set zero)
			 *
			 * "driver status" is mutually exclusive with "conflict
			 * resolved", therefore there are only six permutations
			 * rather than eight
			 *
			 * the message is selected by using the low order three
			 * bits of `m' to encode a condition:
			 *
			 *	+----------------+
			 *	|       N  X  Z  |
			 *	+------ |  |  | -+
			 *	        |  |  +---- set zero
			 *	        |  +------- EXCLUDED
			 *	        +---------- value numeric
			 */
			static short message[8] ={ ER74, ER76, ER75, 0, ER71, ER73, ER72, 0 };
			int m = 0;
			int number;
			char *string;

			dp = cp[0].dp;

			if ((pp1=cp[0].pp)->type == 'N')
				{
				number = pp1->value.number;
				m |= 04;
				}
			else
				string = POINTER(pp1->value.string,dp->opthdr);

			if (dp->flag & EXCLUDE)
				{
				m |= 02;
				pp1->name[0] = '\0';			/* it cannot be found again */
				}
			else
				if (setzero)
					{
					m |= 01;
					pp1->type = 'N';
					pp1->value.number = 0;
					}

			switch (m = message[m])
				{
			case ER71:
				/* <driver>: <parameter> = <n> */
			case ER72:
				/* <driver>: <parameter> = <n> (<driver EXCLUDED, parameter ignored) */
			case ER73:
				/* <driver>: <parameter> = <n> (set to zero) */
				error(m, dp->name, name, number, dp->name);
				break;
			case ER74:
				/* <driver>: <parameter> = "<s>" */
			case ER75:
				/* <driver>: <parameter> = "<s>" (<driver EXCLUDED, parameter ignored) */
			case ER76:
				/* <driver>: <parameter> = "<s>" (set to zero) */
				error(m, dp->name, name, string, dp->name);
				break;
				}
			}

		Scp = last;
		}

	free(check);
	}

/*
 * checkcmp(cp1, cp2)
 * 
 * Compare the parameter values of two check structures;  return TRUE if the
 * values are equal and return FALSE if the values are not equal
 */
 static
 boolean
checkcmp(cp1, cp2)
	register struct check *cp1, *cp2;
	{PROGRAM(checkcmp)

	register struct param *pp1, *pp2;

	if ((pp1=cp1->pp)->type == (pp2=cp2->pp)->type)
		/*
		 * types are the same, the actual values must be compared
		 */
		switch (pp1->type)
			{
		case 'N':
			return(pp1->value.number == pp2->value.number);
		case '"':
			return(strcmp(POINTER(pp1->value.string,cp1->dp->opthdr),
					POINTER(pp2->value.string,cp2->dp->opthdr)) == 0);
			}

	/*
	 * types are not the same (values cannot be the same), or the
	 * values did not compare equal
	 */
	return(FALSE);
	}

/*
 * Absolute()
 *
 *	This routine loads the absolute boot program from bootprogram.path
 */

static
int
(*absolute(p))()
	register char *p;
	{PROGRAM(absolute)

	register int fd, i;
	register SCNHDR *shdr = NULL;
	register int (*entry)() = (int(*)())0xFFFFFFFF;
	register struct s3bc *s3bc;
	int j;
	FILHDR header;
	SCNHDR section;

	if(p == NULL)
		p = bootprogram.path;

	if ((fd=open(p)) == -1)
		SIGNAL(ABORT);

	ON(IOERROR)
		goto exit;

	/*
	 * if section <EDT> is found, then it is an absolute boot file created
	 * by mkunix(1M) -- confirm that the current configuration is compatible
	 */

	read_and_check(fd, (char*)&header, FILHSZ);
	seek_and_check(fd, (long)header.f_opthdr, 1);
	j = header.f_nscns;		/* number of section headers */

	while (j-- != 0)
		{

		read_and_check(fd, (char*)&section, SCNHSZ);

		if (! (section.s_flags & STYP_DSECT))
			continue;

		if (0 != strcmp("<EDT>",section.s_name))
			continue;

		/*
		 * read the sys3bconfig structure
		 */

		if ((sys3bconfig=(struct s3bconf*)malloc((unsigned)section.s_size)) == NULL)
			panic("No memory for sys3bconfig structure");

		seek_and_check(fd, (long)section.s_scnptr, 0);
		read_and_check(fd, (char*)sys3bconfig, (unsigned)section.s_size);

		/*
		 * confirm that devices existing now were configured before
		 */
		ON(ABORT)
			goto exit;

		edtscan(EDT_START, 0, confirm);
		xconfirm(XS3BCONFSTART);	/* check TC configuration for
						 * all configured HA's. XCONFSTART
						 * is a pointer to a linked list of
						 * equipped TC's.
						 */

		REVERT(ABORT);

		/*
	 	 * confirm that previously configured devices still exist now
		 */
		for (i=0, s3bc=sys3bconfig->driver; i<sys3bconfig->count; ++i, ++s3bc)
			{
			boolean fail;
			char buffer[DIRSIZ+1];

#ifdef u3b2
			if (!strcmp(s3bc->name, "SBD")) {
				if (s3bc->timestamp > SIZOFMEM) {
					fail = (boolean)error(ER77, p);
					if (fail)
						goto exit;
				}
				if (s3bc->timestamp < SIZOFMEM) {
					fail = (boolean)error(ER78, p);
					if (fail)
						goto exit;
				}
			}
#endif
			if (s3bc->flag & S3BC_IGN || s3bc->board == 0)
				/* device is ignored, it exists now, or this is a software driver */
				continue;

			strncat(strcpy(buffer,""), s3bc->name, sizeof(s3bc->name));

 			if (s3bc->board & 0xF0 && !(s3bc->flag & S3BC_TCDRV))
				/* Device <name> previously configured on LBE (board code <n>) at ELB board code <n> */
				fail = (boolean)error(ER40, buffer, (s3bc->board & 0xF0) >> 4, s3bc->board & 0x0F);
			else
				/* Device <name> previously configured at board code <n> */
 				fail = (boolean)error(ER41, buffer, s3bc->board);

			/*
			 * If configuration changed and AUTO BOOT, try etc/system.
			 */
			if (fail)
				goto exit;
			}

		free((char*)sys3bconfig);
		sys3bconfig = NULL;
		break;
		}

	alloc_loadmap((unsigned)header.f_nscns);	/* allocate load map */

	/*
	 * load file sections
	 */

	if ((shdr=coff_section(p)) == NULL)
		goto exit;

	do	{
#if DEBUG1
		if (prt[_LOADUNIX])
			{
			printf("\nSection header:\n");
			printf("     s_name   = %s\n", shdr->s_name);
			printf("     s_paddr  = 0x%lX\n", shdr->s_paddr);
			printf("     s_vaddr  = 0x%lX\n", shdr->s_vaddr);
			printf("     s_size   = 0x%lX\n", shdr->s_size);
			printf("     s_scnptr = 0x%lX\n", shdr->s_scnptr);
			printf("     s_relptr = 0x%lX\n", shdr->s_relptr);
			printf("     s_nreloc = %d\n", shdr->s_nreloc);
			printf("     s_flags  = 0x%lX\n", shdr->s_flags);
			}
#endif

		if (shdr->s_scnptr == 0)
			continue;
		if ((shdr->s_flags & STYP_INFO) != 0)
			continue;

		/*
		 * entry point is lowest physical address used
		 */
		entry = (int(*)()) umin((unsigned long)entry, (unsigned long)shdr->s_paddr);

		make_loadmap("UNIX", shdr->s_name, (address)shdr->s_paddr, -1L, shdr->s_size);

		seek_and_check(fd, (long)shdr->s_scnptr, 0);
		read_and_check(fd, (char*)shdr->s_paddr, (unsigned)shdr->s_size);
		}
		while ((shdr=coff_section((char*)NULL)) != NULL);

	close(fd);

	return(entry);

	/*
	 * Error exit
	 */
exit:	while (coff_section((char*)NULL) != NULL)
		continue;

	close(fd);

	if (sys3bconfig)
		{
		free((char*)sys3bconfig);
		sys3bconfig = NULL;
		}
 	xunalloc_s3bconf(XS3BCONFSTART);	/* deallocate config table for
 						 * two level devices (TC's) */
	SIGNAL(ABORT);
	/*NOTREACHED*/
	}

/*
 * Confirm(edtp, lba, elb)
 *
 * Confirm that devices that exist now were configured at the time the
 * sys3bconfig structure was created
 */
 static
 void
confirm(edtp, lba, elb)
	register struct edt *edtp;
	int lba;
	int elb;
	{PROGRAM(confirm)

	register struct s3bc *s3bc;
	register i;

#ifdef u3b15
	/*
	 * ignore IOA controlled devices
	 */
	if (edtp->ioa_edti != 0)
		return;
#endif

	/*
	 * find the matching device for this EDT entry
	 */
	for (i=0; i<sys3bconfig->count; ++i)
		{
		s3bc = &sys3bconfig->driver[i];

		if (0 != strcmp(edtp->dev_name,s3bc->name))
			continue;

		if (s3bc->flag & S3BC_IGN)
			/* ignored before, therefore ignore it now */
			return;

		if (s3bc->board == ((lba<<4) | elb))
			/* found it, therefore mark it found */
			{
			s3bc->board = 0;
			if(edtp->indir_dev)
				/* load bus gen program for configured
				 * HA device.
				 */
				ldebusgen(NULL, elb, edtp->dev_name);
			return;
			}
		}

	if ((i=lba) == 0)
		i = elb;

	/* Device <edtp->dev_name> (board code <n>) not configured */
	/* Device <edtp->dev_name> (LBE <n>, board code <n>) not configured */
	if (error(lba? ER43 : ER42, edtp->dev_name, i, elb))
		SIGNAL(ABORT);
	}
/*
 * xconfirm(p)
 *
 * Confirm that TC devices that exist now were configured at the time the
 * sys3bconfig structure was created
 */
static
void
xconfirm(p)
	register struct xs3bconf *p;
{PROGRAM(xconfirm)

	register struct s3bc *s3bc;
	register i;

	while(p != NULL){

		/*
		 * find the matching device for this XEDT entry
		 */
		for (i=0; i<sys3bconfig->count; ++i){
			s3bc = &sys3bconfig->driver[i];
			if (0 != strcmp(p->tcname,s3bc->name))
				if(i+1 == sys3bconfig->count){
					if(error(ER86, p->tcname, p->maj, p->haslot))
						SIGNAL(ABORT);
				}else 
					continue;
	
			if (s3bc->flag & S3BC_IGN)
				/* ignored before, therefore ignore it now */

				break;
	
			if (s3bc->board == p->maj){
				/* found it, therefore mark it found */

				s3bc->board = 0;
				break;
			}
		}
		XS3BCONFSTART = p->next;	/* look at next entry */
		free((char*)p);
		p = XS3BCONFSTART;
	}
	
}

/*
 * Relocatable()
 *
 *	This routine loads the boot program which must be configured.
 *
 *	All real sections (names not beginning with .) are
 *	loaded; no relocation is done except for undefined symbols.
 *	It is assumed that all real sections will occupy the
 *	lower portion of mainstore.  The high-water mark is kept
 *	and is used as the origin of the virtual sections.
 *
 *	All virtual sections (names beginning with .) are loaded
 *	except .text, .data and .bss; again no relocation is done
 *	except for undefined symbols.  The special symbols S<name>,
 *	E<name> and <name>SIZE are defined, where <name> is the
 *	section name without the '.'.  The section corresponding to
 *	virtual 0 must exist and be loaded; its real address is
 *	remembered so that interrupt vectors can be inserted.  Each
 *	section is loaded at the next highest page boundry.
 *
 *	At this time, location counters are assigned for the kernel
 *	text and data sections.  The sections .text, .data and .bss
 *	are then loaded; again, no relocation is done except for
 *	undefined symbols.  The special symbols S<name>, E<name> and
 *	<name>SIZE are created.
 *
 *	Finally, the drivers are loaded.
 *
 *	The process is completed by initializing all driver data
 *	structures, assigning the real address for the bss section,
 *	and finishing the sys3b symbol table.
 */
 static
 int
(*relocatable(fhdr))()
	FILHDR *fhdr;
	{PROGRAM(relocatable)

	extern boolean	DebugMode;
	register SCNHDR *shdr;
	register struct driver *dp;
	register struct rtname *rtn;
	register int (*entry)() = (int(*)())0xFFFFFFFF;
	int fd = -1;
	int number_drivers;		/* total number of drivers/modules to be loaded */
	int fscnt;
	SYMBOL *p_edata, *p_end;
	SCNHDR text, data, bss;
	address temp;
	struct s3bsym *sys3bsym;


	if ((fd=open(bootprogram.path)) == -1)
		SIGNAL(ABORT);

	ON(IOERROR)
		goto fail2;

	ON(ABORT)
		goto fail2;

	/*
	 * Get the section headers for .text, .data and .bss
	 */

	if ((shdr=coff_section(bootprogram.path)) == NULL)
		goto fail2;

	do	{
#if DEBUG1
		if (prt[_LOADUNIX])
			{
			printf("\nSection header:\n");
			printf("     s_name   = %s\n", shdr->s_name);
			printf("     s_paddr  = 0x%lX\n", shdr->s_paddr);
			printf("     s_vaddr  = 0x%lX\n", shdr->s_vaddr);
			printf("     s_size   = 0x%lX\n", shdr->s_size);
			printf("     s_scnptr = 0x%lX\n", shdr->s_scnptr);
			printf("     s_relptr = 0x%lX\n", shdr->s_relptr);
			printf("     s_nreloc = %d\n", shdr->s_nreloc);
			printf("     s_flags  = 0x%lX\n", shdr->s_flags);
			}
#endif

		if (0 == strcmp(".text",shdr->s_name))
			{
			text = *shdr;
			continue;
			}
		if (0 == strcmp(".data",shdr->s_name))
			{
			data = *shdr;
			continue;
			}
		if (0 == strcmp(".bss",shdr->s_name))
			{
			bss = *shdr;
			continue;
			}
		}
		while ((shdr=coff_section((char*)NULL)) != NULL);

	/*
	 * Initialize the BSS location counter
	 */
	bss_locctr.v_locctr = (address)bss.s_vaddr;
	bss_locctr.v_origin = (address)bss.s_vaddr;

	/*
	 * Load the kernel's symbol table (and allocate kernel BSS)
	 */
	Ksymread(fhdr->f_nsyms);

	for (rtn=rtname; rtn->name; ++rtn)
		{
		if ((rtn->symbol=Ksym_name(rtn->name)) == NULL)
			{
			/* <bootprogram.path>: routine <rtn->name>() not found */
			error(ER65, bootprogram.path, rtn->name);

			rtn->symbol = define(rtn->name, 0L);
			}
		}

	/*
	 * load the real sections; all sections whose names
	 * do not begin with a period are assumed to be bound to
	 * real addresses
	 */

	if ((shdr=coff_section(bootprogram.path)) == NULL)
		goto fail2;

	do	{
		if (shdr->s_name[0] == '.')
			continue;

		if (shdr->s_scnptr > 0)
			{
			/*
			 * entry point is lowest physical address used
			 */
			entry = (int(*)()) umin((unsigned long)entry, (unsigned long)shdr->s_paddr);

			if (! Kload(fd,shdr,(address)shdr->s_paddr))
				goto fail2;

			make_loadmap("UNIX", shdr->s_name, (address)shdr->s_paddr, -1L, shdr->s_size);
			}

		hiwater = umax(hiwater, (unsigned)shdr->s_paddr + shdr->s_size);
		}
		while ((shdr=coff_section((char*)NULL)) != NULL);

#if TEST
	elapsed("Unix real sections loaded");
#endif

	/*
	 * load all virtual sections except .text, .data and .bss
	 */

	hiwater = ctob(btoc(hiwater));

	if ((shdr=coff_section(bootprogram.path)) == NULL)
		goto fail2;

	do	{
		char basicname[1+sizeof(shdr->s_name)];
		char name[2*8+1];

		if (shdr->s_name[0] != '.')
			continue;

		if ((shdr->s_flags & STYP_INFO) != 0)
			continue;

		if (0 == strcmp(text.s_name,shdr->s_name))
			continue;
		if (0 == strcmp(data.s_name,shdr->s_name))
			continue;
		if (0 == strcmp(bss.s_name,shdr->s_name))
			continue;

		strncat(strcpy(basicname,""), shdr->s_name+1, sizeof(shdr->s_name)-1);

		if (shdr->s_vaddr == 0)
			virtual0 = hiwater;

		if (shdr->s_scnptr > 0)
			{
			if (! Kload(fd,shdr,hiwater))
				goto fail2;

			make_loadmap("UNIX", shdr->s_name, hiwater, (address)shdr->s_vaddr, shdr->s_size);
			}

		/*
		 * define variables S<name>, E<name> and <name>SIZE
		 */
		allocate(&hiwater, strcat(strcpy(name,"S"),basicname), shdr->s_size);
		define(strcat(strcpy(name,"E"),basicname), hiwater);
		define(strcat(strcpy(name,basicname),"SIZE"), (address)shdr->s_size);

		hiwater = ctob(btoc(hiwater));
		}
		while ((shdr=coff_section((char*)NULL)) != NULL);

	if (virtual0 == -1)
		/* No section loaded at virtual address zero; interrupt vectors are inaccessible */
		error(ER44);

	/*
	 * Initialize TEXT and DATA location counters
	 *
	 * We now have enough information to begin generating the data structures
	 * necessary for the drivers.
	 *
	 * We know the size and virtual origin of the kernel's text, data and bss.
	 * We know the total size of all driver's text.  We know the number of interrupt
	 * routines that must be generated.  We know the high-water mark in memory for
	 * the real and virtual sections.  We know the real address of virtual zero.
	 */
	define("Stext", hiwater);
	text_locctr.v_locctr = (address)text.s_vaddr + text.s_size;
	text_locctr.v_origin = (address)text.s_vaddr;
	text_locctr.p_origin = hiwater;

	hiwater += text.s_size + IRTNSIZE*interrupts + driver_text + PREFETCH;

	define("Etext", hiwater);
	define("textSIZE", hiwater - text_locctr.p_origin);

	hiwater = ctob(btoc(hiwater));

	define("Sdata", hiwater);
	data_locctr.v_locctr = (address)data.s_vaddr + data.s_size;
	data_locctr.v_origin = (address)data.s_vaddr;
	data_locctr.p_origin = hiwater;

#if TEST
	elapsed("Unix virtual sections (except .text & .data) loaded");
#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	/*
	 * build all interrupt routines, pcb's, kernel data structures for I/O, etc.
	 */
	build_io_subsys();

#if TEST
	elapsed("Unix I/O subsystem generated");
#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	/*
	 * allocate any variables required by the kernel
	 */
	alloc_variables((struct driver *)kernel);

	/*
	 * copy "sys3bboot"
	 */
	generate(G_DATA, "sys3bboot", sizeof(bootprogram), &bootprogram);

	/*
	 * load UNIX .text
	 */
	if (! Kload(fd,&text,text_locctr.p_origin))
		goto fail2;

	make_loadmap("UNIX", text.s_name, text_locctr.p_origin, (address)text.s_vaddr, text.s_size);

	/*
	 * load UNIX .data
	 */
	if (! Kload(fd,&data,data_locctr.p_origin))
		goto fail2;

	make_loadmap("UNIX", data.s_name, data_locctr.p_origin, (address)data.s_vaddr, data.s_size);

	close(fd);
	fd = -1;

#if TEST
	elapsed("Unix .text and .data loaded");
#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	make_loadmap("UNIX", bss.s_name, -1L, (address)bss.s_vaddr, 0L);

	/*
	 * get the memory for the N_index[] and N_value[] arrays
	 */
	if ((N_index = (SYMBOL**) malloc((unsigned)driver_symbol*(sizeof(*N_index)+sizeof(*N_value)))) == NULL)
		goto fail1;
	N_value = (address*) (N_index + driver_symbol);

	/*
	 * load drivers
	 */

	ON(ABORT)
		goto fail2;

	number_drivers = 0;

	dp = driver;

	do	{
		if (dp->flag & LOAD)
			{
			if (! (dp->flag & INEDT || dp->flag & ISEBUS))
				++number_drivers;

			loadriver(dp);
			}
		}
		while (dp = dp->next);

	free((char*) N_index);
	N_index = NULL;

	*next_init++ = NULL;
	generate(G_DATA, "io_init", (next_init-io_init)*sizeof(*io_init), (char*)io_init);

	*next_start++ = NULL;
	generate(G_DATA, "io_start", (next_start-io_start)*sizeof(*io_start), (char*)io_start);

	*next_pwrclr++ = NULL;
	generate(G_DATA, "pwr_clr", (next_pwrclr-pwr_clr)*sizeof(*pwr_clr), (char*)pwr_clr);

#if TEST
	elapsed("Drivers loaded");
#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	/*
	 * allocate the sys3bconfig structure
	 */
	alloc_sys3bconfig(edt_count + xs3bconfcount  + number_drivers);

	/*
	 * allocate final symbols and wrap-up the symbol table
	 */
	generate(G_TEXT, "_filtxt", PREFETCH, "\017\017\017\017\017\017\017\017\017\017\017\017");

	if (text_locctr.v_locctr - text_locctr.v_origin != Xsym_name("textSIZE")->value)
		panic("textSIZE");

	/*
	 * create symbol "etext"; it had better not already be defined
	 */
	define("etext", text_locctr.v_locctr);

	/*
	 * enter "edata" and "end" into the symbol table; again, they had better
	 * not already be defined
	 */
	if ((p_edata=Ksym_name("edata")) == NULL)
		(p_edata = Xsym_name("edata"))->flag |= DEFER;
	else
		/* <edata>: already defined */
		error(ER45, p_edata->name);

	if ((p_end=Ksym_name("end")) == NULL)
		(p_end = Xsym_name("end"))->flag |= DEFER;
	else
		/* <end>: already defined */
		error(ER45, p_edata->name);

	Xsym_name("sys3bsym")->flag |= DEFER;
	Xsym_name("dataSIZE")->flag |= DEFER;
	Xsym_name("Edata")->flag |= DEFER;
	Xsym_name("Sbss")->flag |= DEFER;
	Xsym_name("bssSIZE")->flag |= DEFER;
	Xsym_name("Ebss")->flag |= DEFER;
	Xsym_name("END")->flag |= DEFER;

	/*
	 * resolve any undefined symbols
	 */
	Xsym_walk(NULL, Xsym_resolve);

	/*	If debugging mode was specified, then call
	**	Ksym_copyall.  This will copy all defined
	**	entries from Ksymtab to Xsymtab so that
	**	they will end up in the sys3b symbol table.
	*/

	if (DebugMode)
		Ksym_copyall();

	/*
	 * initialize the driver data structures (this may involve resolving
	 * address-of initializers which may need to be resolved with routine
	 * references in unloaded drivers; if so additional symbols will be
	 * created)
	 */
	initdata((struct driver*)kernel,0);

	dp = driver;

	fscnt = 0;
	do	{
	register struct master *mp1;
		mp1 = dp->opthdr;
		if ((mp1->flag & FSTYP) && (dp->flag & LOAD)){
		fscnt++;
		}
		if (dp->flag & LOAD)
			initdata(dp,fscnt);
		}
		while (dp = dp->next);

	/*
	 * allocate the space necessary for the sys3bsym symbol table; this
	 * is the last thing to create -- thus all remaining addresses can
	 * now be computed
	 */
	allocate(&data_locctr.v_locctr, "sys3bsym", (long)(sizeof(struct s3bsym)+Xsym_size));

	temp = data_locctr.v_locctr - data_locctr.v_origin;
	allocate(&temp, "dataSIZE", (long)data_locctr.p_origin);
	define("Edata", temp);

	if (! (p_edata->flag & DEFINED))
		define(p_edata->name, data_locctr.v_locctr);

	hiwater = temp;

	if (hiwater > lowater)
		/* Memory overflow */
		error(ER1);

	bss_locctr.p_origin = ctob(btoc(temp));
	define("Sbss", bss_locctr.p_origin);
	temp = bss_locctr.v_locctr - bss_locctr.v_origin;
	allocate(&temp, "bssSIZE", (long)bss_locctr.p_origin);
	define("Ebss", temp);

	if (! (p_end->flag & DEFINED))
		define(p_end->name, bss_locctr.v_locctr);

	define("END", temp);

	/*
	 * copy symbol table to kernel data for sys3b(2) system call
	 */
	sys3bsym = (struct s3bsym*) REAL(Xsym_name("sys3bsym")->value, data_locctr);
	sys3bsym->size = sizeof(struct s3bsym) + Xsym_size;
	sys3bsym->count = Xsym_count;
	Xsym_copy((SYMBOL*)NULL, 0, sys3bsym);

	return(entry);

	/*
	 * Error exits
	 */
fail1:
	printf("No memory for driver symbol table processing\n");


fail2:	REVERT(ABORT);

	if (fd != -1)
		close(fd);

	while (coff_section((char*)NULL) != NULL)
		continue;

	if (N_index)
		{
		free((char*)N_index);
		N_index = NULL;
		}

	SIGNAL(ABORT);
	/*NOTREACHED*/
	}

/* xalloc_s3bconf - build xedt config table (2 level bus devices). The 
 * xconfig() routine will copy the contents of this table to the 
 * the system sys3bconf table; The system sys3bconfig table is available
 * to users via sys3b(). 
 */

static void
xalloc_s3bconf(maj, tcname, haslot)
register int maj;			/* TC external major number */
register char *tcname;				/* name of TC driver */
register int haslot;			/* HA slot TC resides on */
{PROGRAM(xalloc_s3bconf)

	struct xs3bconf *p;

	if(NULL == (p = (struct xs3bconf*)malloc(sizeof(struct xs3bconf))))
		panic("No memory for extended sys3bconfig structure");

	p->next = XS3BCONFSTART;
	p->maj = maj;
	p->haslot = haslot;
	strncpy(p->tcname, tcname, sizeof(p->tcname));
	XS3BCONFSTART = p;
	++xs3bconfcount;		/* number of entries on link list */
}

/* xunalloc_s3bconf - configuration changed, therefore unallocate extended
 * sys3bconf (xs3bconf) structure before restarting the boot process. Failure
 * during a powerup boot will default to an etc/system boot. Failure on 
 * demand absolute boot will prompt for path name.
 */

static void
xunalloc_s3bconf(p)
register struct xs3bconf *p;
{PROGRAM(xunalloc_s3bconf)

	while(p != NULL){
 		XS3BCONFSTART = p->next;
 		free((char *)p);
 		p = XS3BCONFSTART;
 	}
 	XMAJNUM = HTCMAJ;		/* starting major for TC's */
 	xs3bconfcount = 0;
 }
 
/* Alloc_sys3bconfig(count)
 *
 * Allocate the sys3bconfig structure and copy it to kernel data space
 */

alloc_sys3bconfig(count)
	int count;
	{PROGRAM(alloc_sys3bconfig)

	register struct driver *dp;
	register struct s3bc *s3bc;

	if (NULL == (sys3bconfig = (struct s3bconf *)malloc(sizeof(struct s3bconf) +
								count*sizeof(struct s3bc))))
		panic("No memory for sys3bconfig structure");

	/*
	 * populate the sys3bconfig structure with EDT entries
	 */
	sys3bconfig->count = 0;

	edtscan(EDT_START, 0, config);

	/* populate the sys3bconfig structure with xedt entries */

	if(XS3BCONFSTART != NULL)
		xconfig(XS3BCONFSTART);		/* move extended xs3bconf entries
						 * into the system configuration
						 * table.
						 */

	/*
	 * finish the initialization by adding the entries for the software
	 * drivers and configurable modules
	 */
	dp = driver;

	do	{
		if (! (dp->flag & LOAD))
			continue;

		if (dp->flag & INEDT || dp->flag & ISEBUS)
			continue;

		s3bc = &sys3bconfig->driver[sys3bconfig->count++];

		s3bc->timestamp = dp->timestamp;
		strncpy(s3bc->name, dp->name, sizeof(s3bc->name));
		s3bc->flag = (dp->opthdr->flag & NOTADRV)? S3BC_MOD : S3BC_DRV;
		s3bc->board = 0;
		}
		while (dp = dp->next);

	generate(G_DATA, "sys3bconfig", sizeof(struct s3bconf)+(sys3bconfig->count-1)*sizeof(struct s3bc), sys3bconfig);

	free((char*)sys3bconfig);
	}

/*
 * Config(edtp, lba, elb)
 *
 * Fill the sys3bconfig structure from the EDT.  Lba and elb are:
 *
 *				lba	elb
 *				----	----
 *	non-LBE device		   0	3-15
 *	LBE device		3-15	1-15
 */

static
void
config(edtp, lba, elb)
	register struct edt *edtp;
	int lba, elb;
	{PROGRAM(config)

	register struct s3bc *s3bc;
	register struct driver *dp;

#ifdef u3b15
	/*
	 * ignore IOA controlled devices
	 */
	if (edtp->ioa_edti != 0)
		return;
#endif

	/*
	 * if this EDT entry was ignored, remember it so a warning is
	 * not re-issued when the absolute boot file is loaded
	 */
	if (ignoredt(edtp->dev_name))
		{
		s3bc = &sys3bconfig->driver[sys3bconfig->count++];

		s3bc->timestamp = 0;
		strncpy(s3bc->name, edtp->dev_name, sizeof(s3bc->name));
#ifdef u3b2
		if (!strcmp("SBD", edtp->dev_name))
			s3bc->timestamp = SIZOFMEM;
#endif
		s3bc->flag = S3BC_IGN;
		s3bc->board = 0;
		return;
		}

	/*
	 * if this EDT entry was not ignored, then it should have been
	 * configured; if not, then don't include it in the sys3bconfig
	 * structure -- this will cause a warning to be re-issued when
	 * the absolute boot file is loaded
	 */
	if ((dp=searchdriver(edtp->dev_name)) == NULL || ! (dp->flag & LOAD))
		return;

	/*
	 * don't include LBE's at unsupported board addresses or any of the
	 * devices located on the unsupported LBE's -- this will cause a warning
	 * to be re-issued when the absolute boot file is loaded
	 */
	if (dp->flag & ISLBE)
		{
		if (elb != 14 && elb != 15)
			return;
		}
	else
		if (lba != 0)
			{
			register i;
			boolean found;

			if (lba != 14 && lba != 15)
				/* device on an unsupported LBE */
				return;

			/* make sure that this device is actually being configured */
			found = FALSE;
			for (i=0; i<dp->nctl; ++i)
				found = found || (dp->maj[i] == LBEMAJ(lba,elb));

			if (! found)
				return;
			}

	/*
	 * put this EDT entry into the structure
	 */
	s3bc = &sys3bconfig->driver[sys3bconfig->count++];

	s3bc->timestamp = dp->timestamp;
	strncpy(s3bc->name, edtp->dev_name, sizeof(s3bc->name));
	s3bc->flag = S3BC_DRV;
	s3bc->board = (lba<<4) | elb;
	}

/* xconfig - build sys3b config for extended bus devices */
static void
xconfig(p)
register struct xs3bconf *p;
{PROGRAM(xconfig)

	register struct s3bc *s3bc;
	register struct driver *dp;

	while(p != NULL){
		/*
		 * if this EDT entry was ignored, remember it so a warning is
		 * not re-issued when the absolute boot file is loaded
		 */
		if (ignoredt(p->tcname)){
			s3bc = &sys3bconfig->driver[sys3bconfig->count++];
			s3bc->timestamp = 0;
			strncpy(s3bc->name, p->tcname, sizeof(s3bc->name));
			s3bc->flag = S3BC_IGN;
			s3bc->board = 0;
		}else 

			/*
			 * if this TC was not ignored, then it should have been
			 * configured; if not, then don't include it in the sys3bconfig
			 * structure -- this will cause a warning to be re-issued when
			 * the absolute boot file is loaded
			 */
			if ((dp=searchdriver(p->tcname)) != NULL &&  (dp->flag & LOAD)){
				/*
				 * put this TC into the sys3bconf structure
				 */

				s3bc = &sys3bconfig->driver[sys3bconfig->count++];
				s3bc->timestamp = dp->timestamp;
				strncpy(s3bc->name, p->tcname, sizeof(s3bc->name));
 				s3bc->flag = (S3BC_DRV|S3BC_TCDRV);
				s3bc->board = p->maj;		/* major number of TC */
			}

		XS3BCONFSTART = p->next;	/* look at next entry */
		free((char *)p);
		p=XS3BCONFSTART;
	}
}

/*
 * Alloc_variables()
 *
 * This routine will allocate any variables which are declared in the
 * optional header built by mkboot(1M).  These variables will be initailized
 * later if necessary.
 */
 static
 void
alloc_variables(dp)
	register struct driver *dp;
	{PROGRAM(alloc_variables)

	register struct master *mp = dp->opthdr;
	register SYMBOL *sp;
	register long number;
	register char *name;
	struct cdevsw *cdevp;

	cdevp = & cdevswp[ dp->int_major ];

	if (mp->nvar)
		{
		register struct variable *vp = (struct variable *)POINTER(mp->o_variable,mp);
		int dim;

		if (mp->flag & (CHAR | FUNDRV) && mp->flag & TTYS)
			/*
			 * set cdevsw[].d_ttys
			 */
			Xrelocate(&cdevp->d_ttys, R_DIR32, (char*)POINTER(vp->name,mp));

		for (number = 0; number < mp->nvar; ++number, ++vp)
			{
			if (vp->dimension == NULL)
				dim = 1;
			else
				dim = eval((union element *)POINTER(vp->dimension,mp), dp);

			name = (char *)POINTER(vp->name,mp);

			if ((sp = Ksym_name(name)) != NULL)
				{
				/* <name>: already allocated */
				error(ER62, name);
				continue;
				}
			if ((sp = Xsym_name(name))->flag & DEFINED)
				{
				sp->flag |= NOINIT;

				/* <name>: previously allocated */
				error(ER48, name);
				continue;
				}

			if (vp->ninit)
				generate(G_UDATA, name, (long)((dim*vp->size+sizeof(int)-1) & ~(sizeof(int)-1)));
			else
				allocate(&bss_locctr.v_locctr, name, (long)dim*vp->size);
			}
		}
	}

/*
 * Build_io_subsys()
 *
 * This routine will generate the UNIX kernel's interface to the I/O
 * subsystem.  The following things will be generated here:
 *
 *	MAJOR and MINOR translate tables
 *	cdevcnt, and the initial cdevsw table
 *	bdevcnt, and the initial bdevsw table
 *	the xx_addr[] array if required
 *	the LBE[2][256] vector array if LBE's exist
 *	interrupt routines and PCBs
 *
 *	rootdev
 *	dumpdev
 *	pipedev
 *	swapdev, swplo, nswap
 *
 *	space for the io_init[], io_start[] and pwr_clr[] arrays
 */

#define RX	0x80	/* vectors are paired receive/transmit */
#define XR	0x40	/* vectors are paired transmit/receive */
#define T	1
#define F	0

 static
 void
build_io_subsys()
	{PROGRAM(build_io_subsys)

	register struct driver *dp;
	register struct master *mp;
	register i, j;
	int number_drivers =0;		/* total number of drivers/modules to be loaded */
	int nC, order;
	int rcount, xcount, icount;	/* counters to generate interrupt unit numbers */
	int count;
	int vector, vec[MAXCNTL];
	char interrupt_name[7];		/* assembler interrupt routine: int?? or lbe??? */
	char handler_name[9];		/* C language interrupt routine: xxxx?int */
	char pcb_name[7];		/* kernel PCB name: kpcb?? */
	int (**LBE)();			/* if LBE's exist, we need to generate "LBE[2][256]" */
	static char hex[] ={ "0123456789ABCDEF" };

#ifdef u3b15
	struct mmuseg xx_addr[MAXCNTL+1];
	static struct mmuseg mmuseg ={1, 0, KRWE|UNONE, NCPS-1, 0, 0};
#endif

#ifdef u3b2
#define	KVIOBASE	0x60000		/* virtual origin of I/O board 1 */

	paddr_t xx_addr[MAXCNTL+1];
#endif

	/*
	 * call generate to allocate MAJOR, MINOR, cdevcnt, cdevsw[],
	 * bdevcnt, and bdevsw[]
	 */
	generate(G_IOSYS);

#ifdef u3b15
	if ((dp=searchdriver("LBE")) != NULL && dp->flag & LOAD)
		{
		generate(G_UDATA, "LBE", 2*256*sizeof(*LBE));
		LBE = (int(**)()) REAL(Xsym_name("LBE")->value, data_locctr);
		}
#endif

	/*
	 * run through the driver linked-list, and initialize MAJOR, MINOR, and
	 * generate interrupt routines and PCBs
	 */
	dp = driver;

	do	{
		if (! (dp->flag & LOAD))
			continue;

		mp = dp->opthdr;

		++number_drivers;

		/*
		 * if xx_addr[] array is needed, build it
		 */
		if (dp->flag & INEDT && mp->flag & REQADDR)
			{
			char name[10];

			for (i=0; i<dp->nctl; ++i)
				{
#ifdef u3b15
				xx_addr[i] = mmuseg;
				xx_addr[i].base = (dp->maj[i] & 0x0F) * NCPS;

				if (ONLBE(dp->maj[i]))
					xx_addr[i].sys = dp->sys_bits[i];
#endif
#ifdef u3b2
				xx_addr[i] = (paddr_t)(KVIOBASE + (dp->maj[i]-1)*17*NBPS);
#endif
				}


			/* xx_addr[] must be terminated by NULL for sysdef(1M) */
			*((int**)(&xx_addr[dp->nctl])) = NULL;

			strcat(strcpy(name,mp->prefix), "_addr");

			generate(G_DATA, name, (dp->nctl+1)*sizeof(xx_addr[0]), xx_addr);
			}

		if ((mp->flag & NOTADRV) || ((mp->flag & (CHAR | BLOCK | FUNMOD | FUNDRV)) == FUNMOD))
			/*
			 * nothing else to do if not a driver
			 */
			continue;

		/*
		 * set MAJOR[] and MINOR[] appropriately
		 */
		if (mp->flag & SOFT)
			/*
			 * if a software driver, MAJOR set here
			 */
			MAJOR[mp->soft] = dp->int_major;
		else
			/*
			 * set MAJOR and MINOR for hardware drivers
			 */
			if (dp->flag & (INEDT|ISEBUS) && mp->flag & (BLOCK|CHAR|FUNDRV))
				for (i=0; i<dp->nctl; ++i)
					{
					MAJOR[ dp->maj[i] ] = dp->int_major;
					MINOR[ dp->maj[i] ] = i * mp->ndev;
					}

		/*
		 * generate interrupt routines and PCBs
		 */
		if (mp->nvec != 0)
			{

			for (i=0; i<dp->nctl; ++i)
				vec[i] = (dp->maj[i] & 0x0F) * 16;

			/*
			 * set nC to the number of controllers for which
			 * interrupt routines are to be generated; this
			 * is done to enable the pseudo software drivers to
			 * be treated the same as a normal peripheral board
			 */
			if (mp->flag & SOFT || dp->flag & ISEBUS)
				{
				if (mp->vec != 0)
					{
					nC = 1;
					vec[0] = mp->vec;
					order = XR;
					}
				else
					nC = 0;

#ifdef u3b15
				if (0 == strcmp("CONSOLE",dp->name))
					/* the CC console driver vectors are ordered RX */
					order = RX;
#endif
				}
			else
				{
				nC = dp->nctl;
				order = XR;
				}

			icount = rcount = xcount = 0;

			/*
			 * for each controller ...
			 */
			for (i=0; i<nC; ++i)
				{
				boolean on_lbe;	/* TRUE if device on a LBE */
				int lbe_unit;	/* if on_lbe, then lbe_unit = 0 or 1 */

				/*
				 * if device is on a LBE, then determine the unit number
				 */
				if (ONLBE(dp->maj[i]))
					{
					register struct driver *p = searchdriver("LBE");
					unsigned char lba;

					on_lbe = TRUE;
					lba = LBELBA(dp->maj[i]);

					lbe_unit = 0;
					while (lba != p->maj[lbe_unit])
						++lbe_unit;
					}
				else
					on_lbe = FALSE;

				/*
				 * for each interrupt vector
				 */
				for (j=0; j<mp->nvec; ++j)
					{
					vector = vec[i] + j;

					if (on_lbe)
						{
						strcpy(interrupt_name, "lbe???");
						interrupt_name[5] = "01"[lbe_unit];
						}
					else
						strcpy(interrupt_name, "int??");

					strcpy(pcb_name, "kpcb??");
					interrupt_name[3] = pcb_name[4] = hex[ vector/16 ];
					interrupt_name[4] = pcb_name[5] = hex[ vector%16 ];

					strcpy(handler_name, mp->prefix);

					if (mp->ndev != 0 && mp->nvec/mp->ndev == 2)
						/*
						 * transmit/receive vectors are:
						 *	transmit[ndev]
						 *	receive[ndev]
						 * except for the CC console
						 *	receive[ndev]
						 *	transmit[ndev]
						 */
						switch (order | ((j<mp->ndev)? T : F))
							{
						case RX | T:
						case XR | F:
							strcat(handler_name, "r");
							count = rcount++;
							break;
						case RX | F:
						case XR | T:
							strcat(handler_name, "x");
							count = xcount++;
							break;
							}
					else
						count = icount++;

					strcat(handler_name, "int");

					generate(G_IRTN, interrupt_name, handler_name, count);

					if (on_lbe)
						/*
						 * no PCB is needed, just fill in LBE[][]
						 */
						{
						Xrelocate((address) &LBE[lbe_unit*256 + vector], R_DIR32, interrupt_name);
						continue;
						}

					if (dp->flag & ISLBE)
						/*
						 * each PCB at a different interrupt priority
						 */
						generate(G_PCB, pcb_name, interrupt_name, 14-2*j, vector);
					else
						generate(G_PCB, pcb_name, interrupt_name, mp->ipl, vector);
					}
				}
			}
		}
		while (dp = dp->next);

	/*
	 * generate the system devices
	 */
	generate(G_DATA, "rootdev", sizeof(rootdev), &rootdev);
#ifdef u3b15
	generate(G_DATA, "dumpdev", sizeof(dumpdev), &dumpdev);
#endif
 	generate(G_DATA, "mirrordev", sizeof(mirrordev), &mirrordev[0]);
	generate(G_DATA, "pipedev", sizeof(pipedev), &pipedev);
	generate(G_DATA, "swapdev", sizeof(swapdev), &swapdev);
	generate(G_DATA, "swplo", sizeof(swplo), &swplo);
	generate(G_DATA, "nswap", sizeof(nswap), &nswap);

	/*
	 * get the space for the io_init[], io_start[] and pwr_clr[] arrays;
	 * these arrays are initialized by loadriver() and allocated by
	 * relocatable()
	 */
	if ((io_init=next_init=(int(**)())malloc((unsigned)(number_drivers+1)*(sizeof(*io_init)+sizeof(*io_start)+sizeof(*pwr_clr)))) == NULL)
		panic("No memory for io_init[], io_start[] or pwr_clr[]");

	io_start = next_start = io_init + number_drivers + 1;

	pwr_clr = next_pwrclr = io_start + number_drivers + 1;
	}

/*
 * Loadriver(dp)
 *
 * Generate all driver variables, load the driver text and data,
 * do relocation, and finish the cdevsw[] and bdevsw[] arrays.
 * The driver is represented by the dp->driver structure.
 *
 * The io_init[], io_start[] and pwr_clr[] arrays are filled here.
 */
 static
 void
loadriver(dp)
	register struct driver *dp;
	{PROGRAM(loadriver)

	register struct master *mp;
	register SYMENT *s;
	register SYMBOL *sp;
	int fd = -1;
	long number;
	address text, data;
	struct bdevsw *bdevp;
	struct cdevsw *cdevp;
	struct fmodsw *fmodp;
	struct fstypsw *fstypp;
	int i;

	mp = dp->opthdr;

	/*
	 * initialize:	bdevp -> correct entry in bdevsw[]
	 *		cdevp -> correct entry in cdevsw[]
	 *		fmodp -> next entry in fmodsw[]
	 *		fstypp-> next entry in fstypsw[]
	 */
	bdevp = & bdevswp[ dp->int_major ];
	cdevp = & cdevswp[ dp->int_major ];

	for (fmodp = fmodswp ; fmodp->f_name[0] != '\0' ; ++fmodp)
		continue;
		  
	if (mp->flag & FSTYP) {
		fstypp = fstypswp;
		if (fstypp->fs_init == 0) {
			register struct fstypsw *f = fstypp;
			f->fs_init = f->fs_iput =  
			f->fs_filler = f->fs_iupdat = f->fs_readi = 
			f->fs_writei = f->fs_itrunc = f->fs_statf =
			f->fs_namei = f->fs_mount = f->fs_umount =
			f->fs_openi = f->fs_closei =
			f->fs_update = f->fs_statfs = f->fs_access = 
			f->fs_getdents = f->fs_allocmap = 
			f->fs_readmap = f->fs_setattr = 
			f->fs_notify = f->fs_fcntl = f->fs_ioctl =
			f->fs_fsinfo =
			  (int(*)()) (rtname[RFSTRAY].symbol->value);
			f->fs_iread = f->fs_getinode = 
			(struct inode *(*)()) (rtname[RFSTRAY].symbol->value);
			f->fs_freemap = (int *(*)()) (rtname[RFSTRAY].symbol->value);
			for (i=0;i<5;i++)
				f->fs_fill[i] = (int(*)()) (rtname
					[RFSTRAY].symbol->value);
		}
	for(fstypp = fstypswp; fstypp->fs_init != 0 ; ++fstypp){
		continue;
	}
	fstypp->fs_init = fstypp->fs_iput =  
	fstypp->fs_filler = fstypp->fs_iupdat = fstypp->fs_readi = 
	fstypp->fs_writei = fstypp->fs_itrunc = fstypp->fs_statf =
	fstypp->fs_namei = fstypp->fs_mount = fstypp->fs_umount =
	fstypp->fs_openi = fstypp->fs_closei =
	fstypp->fs_update = fstypp->fs_statfs = fstypp->fs_access = 
	fstypp->fs_getdents = fstypp->fs_allocmap = 
	fstypp->fs_readmap = fstypp->fs_setattr = 
	fstypp->fs_notify = fstypp->fs_fcntl = fstypp->fs_ioctl =
	fstypp->fs_fsinfo =
	  (int(*)()) (rtname[RFSNULL].symbol->
					value);
	fstypp->fs_iread = fstypp->fs_getinode = 
	(struct inode *(*)()) (rtname[RFSNULL].symbol->value);
	fstypp->fs_freemap = (int *(*)()) (rtname[RFSNULL].symbol->value);
	for (i=0;i<5;i++)
		fstypp->fs_fill[i] = (int(*)()) (rtname
			[RFSNULL].symbol->value);
	}


	/*
	 * set cdevsw[] and bdevsw[] elements to nulldev()/nodev()
	 */
	if (mp->flag & BLOCK)
		{
		register struct bdevsw *p = bdevp;

		p->d_open = p->d_close = p->d_strategy = p->d_print = (int(*)()) (rtname[RNULL].symbol->value);
		}

	if (mp->flag & (CHAR | FUNDRV)) {
		register struct cdevsw *p = cdevp;

		p->d_open = p->d_close = (int(*)()) (rtname[RNULL].symbol->value);
		p->d_read = p->d_write = p->d_ioctl = (int(*)()) (rtname[RNODEV].symbol->value);
		if (mp->flag & FUNDRV) {
			char	name[sizeof(mp->prefix)+4];

			strcat(strcpy(name, mp->prefix), "info");
			Xrelocate(&p->d_str, R_DIR32, name);
		}
	}

	if (mp->flag & FUNMOD) {
		char	name[sizeof(mp->prefix) + 4];

		lcase(strncpy(fmodp->f_name, dp->name,
			sizeof(fmodp->f_name) - 1));
		strcat(strcpy(name, mp->prefix), "info");
		Xrelocate(&fmodp->f_str, R_DIR32, name);
	}

	/*
	 * allocate all of the driver specific variables
	 */
	alloc_variables(dp);

	/*
	 * assign location counters
	 *
	 *	shdr[].s_vaddr   - the virtual-virtual origin of the section
	 *	shdr[].s_paddr   - the computed virtual origin of the section
	 *
	 *	text             - the real origin of the .text section
	 *	data             - the real origin of the .data section
	 */
	text = REAL(text_locctr.v_locctr, text_locctr);
	dp->shdr[0].s_paddr = text_locctr.v_locctr;
	text_locctr.v_locctr += dp->shdr[0].s_size;

	make_loadmap(dp->name, dp->shdr[0].s_name, text, (address)dp->shdr[0].s_paddr, dp->shdr[0].s_size);

	data = REAL(data_locctr.v_locctr, data_locctr);
	dp->shdr[1].s_paddr = data_locctr.v_locctr;
	data_locctr.v_locctr += dp->shdr[1].s_size;

	make_loadmap(dp->name, dp->shdr[1].s_name, data, (address)dp->shdr[1].s_paddr, dp->shdr[1].s_size);

	hiwater = data + dp->shdr[1].s_size;

	dp->shdr[2].s_paddr = bss_locctr.v_locctr;

	make_loadmap(dp->name, dp->shdr[2].s_name, -1L, (address)dp->shdr[2].s_paddr, 0L);

	/*
	 * read the symbol table and build the N_index[] and N_value[] arrays
	 */

	if (chdir(slash_boot) == -1)
		{
		/* <slash_boot>: perror() message */
		error(ER7, slash_boot);
		goto exit;
		}

	if ((s=coff_symbol(dp->name,&number)) != NULL)
		/*
		 * there are some symbols
		 */
		do	{
			char *np;

			if (s->n_sclass == C_TPDEF  ||
			   s->n_sclass == C_MOS    ||
			   s->n_sclass == C_MOU) {
				continue;
			}

			if (s->n_zeroes)
				np = s->n_name;
			else
				np = s->n_name + s->n_offset;

			if (s->n_scnum != 0)
				/*
				 * the symbol is defined within the driver; compute its
				 * final value, and save its original value
				 */
				{
				SCNHDR *sptr;
				int section;

				sptr = & dp->shdr[ section=dp->s_index[s->n_scnum] ];

				/*
				 * If the symbol is a static symbol, then we have a problem --
				 * a symbol of the same name may already exist in the symbol
				 * table.  If define() is called, then a diagnostic will be
				 * issued for the static symbol, so we have to handle static
				 * symbols in a special way.  Xsym_name() is called to add
				 * the symbol to the symbol table.  If it already exists
				 * then somehow a new entry with the same name must be added.
				 * The current entry is saved, the STATIC flag is set and
				 * Xsym_name() called again to get a new entry -- a new entry
				 * is assured since the original entry now has the STATIC
				 * flag set.  Finally, the original symbol table entry is
				 * restored, and we use the newest entry for the static symbol.
				 */

				if (s->n_sclass != C_STAT)
					/*
					 * no problem, the symbol is not static
					 */
					sp = define(np, (address)s->n_value-sptr->s_vaddr+sptr->s_paddr);
				else
					{
					if ((sp=Xsym_name(np))->flag & DEFINED || sp->value != 0)
						/*
						 * we must save this entry, get a new entry, restore
						 * it, and use the newest entry
						 */
						{
						SYMBOL save, *np;

						save = *sp;

						sp->flag |= STATIC;

						np = Xsym_name(sp->name);

						*sp = save;

						sp = np;
						}

					sp->flag |= STATIC | DEFINED;
					sp->value = s->n_value - sptr->s_vaddr + sptr->s_paddr;
					}

				sp->flag |= DRIVER;

				N_index[number] = sp;
				N_value[number] = s->n_value;

				if (section == 0)
					/*
					 * .text
					 */
					{
					register struct bdevsw *b = bdevp;
					register struct cdevsw *c = cdevp;
					register struct fstypsw *f = fstypp;
					if (! (mp->flag & FSTYP))

					if (function(mp->prefix,"init",np))
						*next_init++ = (int(*)()) sp->value;
					if (function(mp->prefix,"start",np))
						*next_start++ = (int(*)()) sp->value;
					if (function(mp->prefix,"clr",np))
						*next_pwrclr++ = (int(*)()) sp->value;

					if (mp->flag & FSTYP) {
						if (function(mp->prefix,"init",np))
							f->fs_init = (int(*)())sp->value;
						if (function(mp->prefix,"iput",np))
							f->fs_iput = (int(*)())sp->value;
						if (function(mp->prefix,"iread",np))
							f->fs_iread = (struct inode  *(*)())sp->value;
						if (function(mp->prefix,"filler",np))
							f->fs_filler = (int(*)()) (rtname[RFSTRAY].symbol->value);
						if (function(mp->prefix,"iupdat",np))
							f->fs_iupdat = (int(*)())sp->value;
						if (function(mp->prefix,"readi",np))
							f->fs_readi = (int(*)())sp->value;
						if (function(mp->prefix,"writei",np))
							f->fs_writei = (int(*)())sp->value;
						if (function(mp->prefix,"itrunc",np))
							f->fs_itrunc = (int(*)())sp->value;
						if (function(mp->prefix,"statf",np))
							f->fs_statf = (int(*)())sp->value;
						if (function(mp->prefix,"namei",np))
							f->fs_namei = (int(*)())sp->value;
						if (function(mp->prefix,"mount",np))
							f->fs_mount = (int(*)())sp->value;
						if (function(mp->prefix,"umount",np))
							f->fs_umount = (int(*)())sp->value;
						if (function(mp->prefix,"getinode",np))
							f->fs_getinode = (struct inode *(*)())sp->value;
						if (function(mp->prefix,"openi",np))
							f->fs_openi = (int(*)())sp->value;
						if (function(mp->prefix,"closei",np))
							f->fs_closei = (int(*)())sp->value;
						if (function(mp->prefix,"update",np))
							f->fs_update = (int(*)())sp->value;
						if (function(mp->prefix,"statfs",np))
							f->fs_statfs = (int(*)())sp->value;
						if (function(mp->prefix,"access",np))
							f->fs_access = (int(*)())sp->value;
						if (function(mp->prefix,"getdents",np))
							f->fs_getdents = (int(*)())sp->value;
						if (function(mp->prefix,"allocmap",np))
							f->fs_allocmap = (int(*)())sp->value;
						if (function(mp->prefix,"freemap",np))
							f->fs_freemap = (int *(*)())sp->value;
						if (function(mp->prefix,"readmap",np))
							f->fs_readmap = (int(*)())sp->value;
						if (function(mp->prefix,"setattr",np))
							f->fs_setattr = (int(*)())sp->value;
						if (function(mp->prefix,"notify",np))
							f->fs_notify = (int(*)())sp->value;
						if (function(mp->prefix,"fcntl",np))
							f->fs_fcntl = (int(*)())sp->value;
						if (function(mp->prefix,"ioctl",np))
							f->fs_ioctl = (int(*)())sp->value;
						if (function(mp->prefix,"fsinfo",np))
							f->fs_fsinfo = (int(*)())sp->value;
						for (i=0;i<5;++i)
							f->fs_fill[i] = (int(*)()) (rtname[RFSNULL].symbol->value);
					}

					if ((mp->flag & NOTADRV) || ((mp->flag & (CHAR | BLOCK | FUNMOD | FUNDRV)) == FUNMOD))
						/*
						 * no more special names if not a driver
						 */
						continue;

					if (function(mp->prefix,"open",np))
						{
						if (mp->flag & BLOCK)
							b->d_open = (int(*)()) sp->value;
						if (mp->flag & CHAR)
							c->d_open = (int(*)()) sp->value;
						}
					if (function(mp->prefix,"close",np))
						{
						if (mp->flag & BLOCK)
							b->d_close = (int(*)()) sp->value;
						if (mp->flag & CHAR)
							c->d_close = (int(*)()) sp->value;
						}
					if (mp->flag & BLOCK)
						{
						if (function(mp->prefix,"strategy",np))
							b->d_strategy = (int(*)()) sp->value;
						if (function(mp->prefix,"print",np))
							b->d_print = (int(*)()) sp->value;
						}
					if (mp->flag & CHAR)
						{
						if (function(mp->prefix,"read",np))
							c->d_read = (int(*)()) sp->value;
						if (function(mp->prefix,"write",np))
							c->d_write = (int(*)()) sp->value;
						if (function(mp->prefix,"ioctl",np))
							c->d_ioctl = (int(*)()) sp->value;
						}
					}
				}
			else
				{
				if (s->n_value != 0)
					/*
					 * BSS symbol
					 */
					{
					N_index[number] = sp = Xsym_name(np);

					sp->flag |= BSS | DRIVER;

					N_value[number] = sp->size = s->n_value;

					allocate(&bss_locctr.v_locctr, np, (long)s->n_value);
					}
				else
					/*
					 * the symbol is an unresolved external reference; it
					 * is either already defined in the kernel or another
					 * driver, or it is a reference to a generated data structure
					 */
					{
					if ((sp=Ksym_name(np)) != NULL)
						N_index[number] = sp;
					else
						N_index[number] = Xsym_name(np);
					N_value[number] = 0;
					}
				}
			}
			while ((s=coff_symbol((char*)NULL,&number)) != NULL);

	/*
	 * load the driver into memory
	 */

	if ((fd=open(dp->name)) == -1)
		{
		/* <dp->name>: perror() message */
		error(ER7, dp->name);
		goto exit;
		}

	ON(IOERROR)
		goto exit;

	/*
	 * load .text
	 */
	seek_and_check(fd, (long)dp->shdr[0].s_scnptr, 0);
	read_and_check(fd, (char*)text, (unsigned)(dp->shdr[0].s_size));

	if ((number=dp->shdr[0].s_nreloc) != 0)
		/*
		 * do any required relocation
		 */
		{
		FILE *stream;

		seek_and_check(fd, (long)dp->shdr[0].s_relptr, 0);

		stream = fdopen(fd);

		while (number-- != 0)
			{
			RELOC reloc;
			address real;

			if (fread((char*)&reloc,RELSZ,1,stream) == 0)
				{
				/* <dp->name>: perror() message */
				/* <dp->name>: truncated read */
				error(ferror(stream)? ER7 : ER49, dp->name);
				(void) fdclose(stream);
				goto exit;
				}

			real = reloc.r_vaddr - dp->shdr[0].s_vaddr + text;

			if ((sp=N_index[reloc.r_symndx])->flag & DRIVER)
				/*
				 * symbol referred-to is defined within this or another driver;
				 * if not this driver then N_value[] will be zero
				 */
				Drelocate(real, reloc.r_type, sp, -N_value[reloc.r_symndx]);
			else
				/*
				 * symbol referred-to is external to the driver
				 */
				Drelocate(real, reloc.r_type, sp, 0L);
			}

		(void) fdclose(stream);
		}

	/*
	 * load .data
	 */
	seek_and_check(fd, (long)dp->shdr[1].s_scnptr, 0);
	read_and_check(fd, (char*)data, (unsigned)(dp->shdr[1].s_size));

	if ((number=dp->shdr[1].s_nreloc) != 0)
		/*
		 * do any required relocation
		 */
		{
		FILE *stream;

		seek_and_check(fd, (long)dp->shdr[1].s_relptr, 0);

		stream = fdopen(fd);

		while (number-- != 0)
			{
			RELOC reloc;
			address real;

			if (fread((char*)&reloc,RELSZ,1,stream) == 0)
				{
				/* <dp->name>: perror() message */
				/* <dp->name>: truncated read */
				error(ferror(stream)? ER7 : ER49, dp->name);
				(void) fdclose(stream);
				goto exit;
				}

			real = reloc.r_vaddr - dp->shdr[1].s_vaddr + data;

			if ((sp=N_index[reloc.r_symndx])->flag & DRIVER)
				/*
				 * symbol referred-to is defined within the driver
				 */
				Drelocate(real, reloc.r_type, sp, -N_value[reloc.r_symndx]);
			else
				/*
				 * symbol referred-to is external to the driver
				 */
				Drelocate(real, reloc.r_type, sp, 0L);
			}

		(void) fdclose(stream);
		}

#if TEST
	elapsed(dp->name);
#if DEBUG1
	if (prt[_LOADUNIX])
		shell();
#endif
#endif

	close(fd);

	(void) chdir("/");

	return;


	/*
	 * Error exit
	 */
exit:	if (fd != -1)
		close(fd);

	(void) chdir("/");

	SIGNAL(ABORT);
	}

/*
 * Function(prefix, name, symbol)
 *
 * Test whether the symbol is prefix-name
 */
 static
 boolean
function(prefix, name, symbol)
	register char *prefix;
	char *name;
	char *symbol;
	{PROGRAM(function)

	register len = strlen(prefix);

	return(0 == strncmp(prefix,symbol,len) && 0 == strcmp(name,&symbol[len]));
	}

/*
 * Routine(name)
 *
 * Symbol "name" is undefined.  Attempt to find a routine definition in
 * an unloaded driver which will resolve the symbol.  If successful, return
 * TRUE, otherwise return FALSE.
 */
 boolean
routine(name)
	register char *name;
	{PROGRAM(routine)

	register struct driver *dp;
	register struct master *mp;
	register struct routine *rp;
	register count;

	dp = (struct driver *)kernel;

	do	{
		if (dp->flag & LOAD)
			/*
			 * driver is already loaded
			 */
			continue;

		if ((mp=dp->opthdr)->nrtn)
			/*
			 * search for a routine of the same name
			 */
			{
			rp = (struct routine *) POINTER(mp->o_routine,mp);

			for (count=0; count<mp->nrtn; ++count, ++rp)
				{
				if (0 == strcmp(name,(char *)POINTER(rp->name,mp)))
					/*
					 * symbol is defined by routine reference
					 */
					{
					switch (rp->id)
						{
					default:
						/* <dp->name>: routine <name>: unknown id; RNULL assumed */
						error(ER50, dp->name, name);
					case RNULL:
						define(name, rtname[RNULL].symbol->value);
						break;
					case RNOSYS:
					case RNODEV:
					case RTRUE:
					case RFALSE:
					case NOPKG:
					case NOREACH:
						define(name, rtname[rp->id].symbol->value);
						break;
						}
#if DEBUG1
					if (prt[_LOADUNIX])
						printf("Routine %s resolved from driver %s\n", name, dp->name);
#endif
					return(TRUE);
					}
				}
			}
		}
		while (dp = dp->next);

	return(FALSE);
	}

/*
 * Initdata()
 *
 * Initialize the generated initialized variables for the drivers.
 */

#define	ALIGN(locctr,type)	((locctr+sizeof(type)-1)&~(sizeof(type)-1))

#define	SETDATA(locctr,type)	*((type*)locctr)

 static
 void
initdata(dp,fscnt)
	struct driver *dp;
	int fscnt;
	{PROGRAM(initdata)

	register struct master *mp;
	register struct variable *vp;
	register struct format *fp;
	register struct  fsinfo *fsin;
	register address locctr;
	SYMBOL *sp;
	int n1, n2;
	char *name;

	if ((mp=dp->opthdr)->nvar > 0)
		{

		vp = (struct variable *) POINTER(mp->o_variable,mp);

		for (n1=0; n1<mp->nvar; ++n1,++vp)
			{
			if (vp->ninit == 0)
				continue;

			name = (char *)POINTER(vp->name,mp);

			if ((sp=Ksym_name(name)) != NULL)
				/*
				 * data structure already allocated by kernel
				 */
				continue;

			if ((sp=Xsym_name(name))->flag & NOINIT)
				/*
				 * data structure was not allocated by alloc_variables()
				 */
				continue;

			locctr = REAL(sp->value, data_locctr);

			fp = (struct format *) POINTER(vp->initializer,mp);

			for (n2=0; n2<vp->ninit; ++n2,++fp)
				{

				if (fp->type & FSKIP)
					{
					locctr = ALIGN(locctr,int);
					locctr += fp->value;
					continue;
					}

				/*
				 * if a character string is being initialized, then
				 * it must be handled here;  eval() cannot be called
				 * since any character string initializer would be
				 * allocated in the data section with a value of 
				 * pointer-to-character
				 */
				if ((fp->type & FTYPE) == FSTRING)
					{
					char pname[PARAMNMSZ+1], *svalue;
					register char type;
					int nvalue;
					union element *xp;
					struct param *pp;

					/*
					 * the only initialization allowed for character
					 * strings is either numeric zero (null fill)
					 * or a character string literal; mkboot(1M)
					 * should have caught all errors except those
					 * caused by initialization by a parameter
					 * name located in another driver
					 */
					if (! (fp->type & FEXPR))
						/*
						 * numeric initialization
						 */
						{
						type = 'N';
						nvalue = fp->value;
						}
					else
						/*
						 * initialization by expression; we only
						 * allow expressions of type:
						 *
						 *	N : zero only
						 *	" : string
						 *	I : numeric or string parameter values
						 */
						{
						xp = (union element *) POINTER(fp->value,mp);

						switch (type = xp->operator)
							{
						case 'N':
							nvalue = eval(xp, dp);
							break;
						case '"':
							svalue = &xp->string[1];
							break;
						case 'I':
							if ((pp=searchparam(&xp->identifier[1])) != NULL)
								{
								if ((type=pp->type) == 'N')
									nvalue = pp->value.number;
								else
									svalue = * (char**) POINTER(pp->value.string,pp);
								break;
								}

							/* <dp->name>: data initializer <&xp->identifier[1]> unknown; zero assumed */
							error(ER30, dp->name, strncat(strcpy(pname,""),&xp->identifier[1],PARAMNMSZ));

							type = 'N';
							nvalue = 0;
							break;
						default:
							/* <dp->name>: illegal character string initialization; zero assumed */
							error(ER66, dp->name);

							type = 'N';
							nvalue = 0;
							break;
							}
						}

					if (type == 'N')
						{
						if (nvalue > 0)
							/* <dp->name>: illegal character string initialization; zero assumed */
							error(ER66, dp->name);

						strncpy((char*)locctr, "", (int)fp->strlen);
						}

					if (type == '"')
						{
						if (strlen(svalue) > fp->strlen)
							/* %s: character string initializer truncated */
							error(ER67, dp->name);

						strncpy((char*)locctr, svalue, (int)fp->strlen);
						if (mp->flag & FSTYP) {
							fsin = &fsinfop[fscnt];
							if (function(mp->prefix,"name",name)){

								fsin->fs_name = (char*)sp->value;
							}
						}
						}

					locctr += fp->strlen;
					continue;
					}

				/*
				 * this is a simple numeric variable initialization
				 */
					{
					register long initial_value;

					if (fp->type & FEXPR)
						initial_value = eval((union element *)POINTER(fp->value,mp), dp);
					else
						initial_value = (short)fp->value;

					switch (fp->type & FTYPE)
						{
					case FCHAR:
						SETDATA(locctr,char) = initial_value;
						locctr += sizeof(char);
						break;
					case FSHORT:
						locctr = ALIGN(locctr,short);
						SETDATA(locctr,short) = initial_value;
						locctr += sizeof(short);
						break;
					case FINT:
						locctr = ALIGN(locctr,int);
						SETDATA(locctr,int) = initial_value;
						locctr += sizeof(int);
						break;
					case FLONG:
						if (mp->flag & FSTYP) {
							fsin = &fsinfop[fscnt];
							if (function(mp->prefix,"flag",name)) {
								fsin->fs_flags = initial_value;
								break;
							}
							if (function(mp->prefix,"notfy",name)) {
								fsin->fs_notify = initial_value;
								break;
							}
						}
						locctr = ALIGN(locctr,long);
						SETDATA(locctr,long) = initial_value;
						locctr += sizeof(long);
						break;
						}
					}
				}
			}
		}
	}

/*
 * Lreset()
 *
 * Reset the values of all variables in this file.  This is necessary to
 * clean-up after a failed boot attempt.
 */
 void
lreset()
	{PROGRAM(lreset)

	register struct driver *dp;
	register struct ignore *ip;

	virtual0 = NULL;
	hiwater = 0;
	driver_text = interrupts = 0;
	cdevcnt = bdevcnt = fmodcnt = fstypcnt = fsincnt =0;

	if (io_init)
		{
		free((char*)io_init);
		io_init = NULL;
		}

	rootdev = pipedev = dumpdev = swapdev = NODEV;
	swplo = nswap = -1;

	if (N_index)
		{
		free((char*)N_index);
		N_index = NULL;
		}

	if (kernel)
		{
		free((char*)kernel);
		kernel = NULL;
		}

	if ((dp=driver) && dp != driver->next)
		do	{
			dp->flag &= ~(LOAD|INCLUDE|EXCLUDE);

			if (! (dp->flag & INEDT))
				dp->nctl = 0;
			}
			while (dp = dp->next);

	ip = edtlist;
	while ((edtlist=ip) != NULL)
		{
		ip = ip->next;

		free((char*)edtlist);
		}
	}
